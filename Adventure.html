<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()" oncontextmenu="return false">
<script>
//Variables used in the basic construction of the board
var spaceSize = 64; //size (in pixels) of each square on the board
var boardRows = 13; //# of rows our board will have
var boardCols = 13; //# of cols
var board = [];
var boardX;
var boardY;
var spaces = [];

var phase = 0; //Used to keep track of what player is doing with each click 
var delay = -2; //Used when we want to add in a real time delay (delay is 1 per frame so delay = 60 means 1 second IRL)
var frame; //keeps track of how many frames since the game began
var entityLayer = []; //Keeps track of whether a space is terrain (== -1), a friendly unit (> -1), or an enemy unit (< -1) (each unit in this array has a unique #)
//When accessing an enemy unit based on its entity layer #, access the correct position in enemyUnits[] with: 
//enemyUnits((entityLayer[x][y]+2)*-1)

//Variables used in movement and pathing functions
var moveableSpaces = [];
var newMoveable;
var moveableGrid = [];
var spaceOffset = [[1,0],[-1,0],[0,1],[0,-1]];
var currX;
var currY;
var path = [];
var pathX;
var pathY;
var moves = [];
var selectedUnit;
var moveParams = [];
var movementHighlights = [];

//Variables used for board scrolling (increase board rows &/or cols to test)
var globalOffsetX = 0;
var globalOffsetY = 0;
var globalSpeedX = 0;
var globalSpeedY = 0;
var scrollSpeed = 4; //To increase scrolls speed change this (not others)

//Variables used to track player units and hp
var playerUnits = [];
var playerHP = [];
var unitMoved = [];

//Variables used to track enemy units and hp
var enemyUnits = [];
var enemyHP = [];
var enemyUnitMoved = [];
var currentEnemy;

//Variables used in attack functions
var attackableSpaces = [];
var newAttackable;
var attackHighlights = [];
var attackCheck = [];
var attacking = 0;
var hpToSet = [];

//Variables to track turn and turn visuals
var turnNumber;
var turnText;
var turnCard;
var turnCardOn = false;
var turnOver = 0; 

//Arrays that hold/keep track of fog of war (not currently implemented)
var fogMap = [];
var fogLayer = [];

//Image for each type of space(/terrain)
var terrainImg = ["grass.png", "trees.png", "mountain.png","river.png",
"friendlyCastle.png","friendlyBarracks.png","friendlyVillage.png",
"barracks.png","village.png", 
"enemyCastle.png", "enemyBarracks.png","enemyVillage.png"];
//Movement cost of space types, currently stats for friendly, neutral, and enemy structures is the same
//But it might make sense to have them differ
var terrainCost = [1,2,3,"X", //terrain
1,1,1, //friendly structures
1,1, //neutral structures
1,1,1]; //enemy structures
var terrainDef = [1,2,3,"X", //Same as above except defense scores
4,3,2,
3,2,
4,3,2];

//Variables used for the unit card (window that shows terrain stats when you click on it)
var terrainCard;
var terrainCardMove;
var terrainCardDef;
var terrainCardSpace;
var terrainCardOn = false;

//Variables used for the unit card (window that shows a units stats when you click on it)
var unitCard;
var unitCardAttack;
var unitCardDef;
var unitCardMove;
var unitCardSight;
var unitCardOn = 0;

//Variables used in capturing and capturing display
var structureMap = [];
var capturing = 0; 
var captureCounter; 
var captureBar = [];
var captureCard;
var capturing = 0;
var captureVal;

//Variables used for building units and the unit building display
var factoryCard;
var factoryCardUnits = [];
var factoryCardUnitBackgrounds = [];
var factoryCardText = [];
var factoryStatCard = [];
var factoryUnitStats = [];
var factoryX;
var factoryY;
var toBuild;
var buildingUnit = false;

//Variables used for money and income
var gold;
var goldText;
var income; 
var incomeText;

//These objects store the stats for each unit, as well as the display images, and their cost to produce
var infantry = {attack: 3, defense: 3, movement: 3, sight: 3, image: "soldier.png", movedImage: "soldierMoved.png", enemyImage: "soldierEnemy.png", name: "Light Infantry", cost: 300};
var heavyInfantry = {attack: 4, defense: 5, movement: 2, sight: 2, image: "knight.png", movedImage: "knightMoved.png", enemyImage: "knightEnemy.png", name: "Heavy Infantry", cost: 600};
var cavalry = {attack: 5, defense: 2, movement: 4, sight: 4, image: "cavalry.png", movedImage: "cavalryMoved.png", enemyImage: "cavalryEnemy.png", name: "Cavalry", cost: 1000};
var archer = {attack: 4, defense: 1, movement: 3, sight: 3, name: "Archer"};

var units = [infantry, heavyInfantry, cavalry];
//current attack function doesn't support long range (yet)
//var units = [infantry, heavyInfantry, cavalry, archer];

function startGame() { //called when the game starts
	frame = 0; 
	turnNumber = 1;
	gold = 500;
	
	if (boardRows * spaceSize > window.innerWidth) //if the board is wider than the screen
		boardX = parseInt(window.innerWidth/spaceSize)*spaceSize; //make the display area however many squares we can fit on the screen 
	else 														  //if not all the spaces fit on screen they can be seen by scrolling
		boardX = boardRows * spaceSize; //otherwise we show the whole board
			
	if (boardCols * spaceSize > window.innerHeight) //same as above except but for vertical
		boardY = parseInt(window.innerHeight/spaceSize)*spaceSize;
	else 
		boardY = boardCols * spaceSize;

	
	
	mapTerrain(); //lays out the map terrain
	mapStructures(); //fills out structureMap[] to represent where buildings are
	
	//Fills out 2D arrays representing the terrain (spaces[]) and location of units (entityLayer[])
	for (var i = 0; i < boardRows; i++) {
		spaces[i] = [];
		entityLayer[i] = [];
		for (var j = 0; j < boardCols; j++) {
				spaces[i][j] = generateSpace(i,j); //creates a space object for each location on the board holding the image and pixel location on the canvas
				entityLayer[i][j] = -1; //We haven't added units so the entity layer is a empty
		}
	}
	
	newPlayerUnit(2, 4, 1); //creates a new player unit at board space x,y of unit type u where the function reads newPlayerUnit(x,y,u)
	newPlayerUnit(2, 2, 2);
	newPlayerUnit(4, 4, 0);
	newPlayerUnit(3, 3, 0);
	
	newEnemyUnit(10, 4, 1); //same as newPlayer unit but for enemies, may condense both into a single function "newUnit" later on
	newEnemyUnit(6, 4, 0);
	newEnemyUnit(9, 3, 0);
	newEnemyUnit(10, 2, 2);
	
	//This section is the decleration of all the visual elements we will need to render on the canvas
	
	//The terrain card is a window that appears when a piece of terrain is selected, that displays its stats, these are the visual components that make up the card
	terrainCard = new component(64, 128, "terrainCard.png", boardX-spaceSize, boardY-spaceSize*2, "none", "none");
	terrainCardMove = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	terrainCardDef = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "3");
	
	//The unit card is the terrain card but for a unit
	unitCard = new component(128, 128, "unitCard.png", boardX-spaceSize*2, boardY-spaceSize*2, "none", "none");
	unitCardAttack = new component("900 32px", "Courier New", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 48, "text", "1");
	unitCardDef = new component("900 32px", "Courier New", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 103, "text", "2");
	unitCardMove = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	unitCardSight = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "4");
	
	//Visual components for showing the capture progress graphic
	for (var i = 0; i < 20; i++) {
		captureBar[i] = new component(64, 10, "solidGrey", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none");
	}
	captureCounter = new component("900 32px", "Courier New", "solidGrey", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", "4");
	captureCard = new component(128, 320, "captureCard.png", boardX-spaceSize*2, boardY-spaceSize*5, "none", "none");
	
	//The factory card is a window that shows money, income, units that can be built, and stats about those units, these are the visual components that make up the card
	factoryCard = new component(spaceSize*9, spaceSize*8, "factoryCard.png", boardX-spaceSize*11, boardY-spaceSize*11, "none", "none");
	goldText = new component("900 32px", "Courier New", "black", toPixel(3,0), toPixel(2,45), "text", "Gold: " + gold);
	incomeText = new component("900 32px", "Courier New", "black", toPixel(7,0), toPixel(2,45), "text", income);
	for (var i = 0; i < units.length; i++) {
		factoryCardUnits[i] = new component(50, 50, units[i].image, toPixel(3,0) + ((spaceSize-50)/2), toPixel(i*2 + 3,0) + ((spaceSize-50)/2), "player", units[i]);
		factoryCardUnitBackgrounds[i] = new component(64, 64, "factoryCardUnitBackground.png", toPixel(3,0), toPixel(i*2 + 3,0), "none", "none");
		factoryCardText[i] = new component("900 32px", "Courier New", "black", toPixel(4,10), toPixel(i*2 + 3,42), "text", units[i].name);
		factoryStatCard[i] = new component(256, 64, "factoryStatCard.png", toPixel(3,0), toPixel(i*2 + 4,0), "none", "none");
		factoryUnitStats[i] = [];
		factoryUnitStats[i][0] = new component("900 32px", "Courier New", "white", toPixel(3,35), toPixel(i*2 + 4,45), "text", units[i].attack);
		factoryUnitStats[i][1] = new component("900 32px", "Courier New", "white", toPixel(4,30), toPixel(i*2 + 4,45), "text", units[i].movement);
		factoryUnitStats[i][2] = new component("900 32px", "Courier New", "white", toPixel(5,25), toPixel(i*2 + 4,45), "text", units[i].defense);
		factoryUnitStats[i][3] = new component("900 32px", "Courier New", "white", toPixel(6,27), toPixel(i*2 + 4,45), "text", units[i].sight);
	}
	
	//The turn card is displayed at the end of each turn and shows what turn it is
	turnText = new component("bold 68px", "Courier New", "black", (boardCols-2.9)*spaceSize/2, boardRows*spaceSize/2, "text", "DAY " + turnNumber);
	turnCard = new component(spaceSize*5, spaceSize*2, "turnCard.png", (boardCols-4.8)*spaceSize/2, (boardRows-2.6)*spaceSize/2, "none", "none");
	
	refreshIncome(); //Sets income text to be correct based on # of friendly structures
	
	gameArea.start(); //Starts the game
}


function mapTerrain() { //edit this to edit terrain (aka place mountain, change forrest to river ect.)
	for (var i = 0; i < boardRows; i++) {
		board[i] = [];
		for (var j = 0; j < boardCols; j++) {
			board[i][j] = 0;
		}
	}
	
	//player's base
	board[1][1] = 4;
	board[1][2] = 5;
	board[2][1] = 5;
	board[1][3] = 6;
	board[3][1] = 6;
	
	//enemy base
	board[11][1] = 9;
	board[11][2] = 10;
	board[10][1] = 10;
	board[11][3] = 11;
	board[9][1] = 11;
	
	//southern island
	board[4][12] = 3;
	board[4][11] = 3;
	board[4][10] = 3;
	board[8][12] = 3;
	board[8][11] = 3;
	board[8][10] = 3;
	board[5][9] = 3;
	board[7][9] = 3;
	
	board[5][12] = 8;
	board[7][12] = 8;
	board[6][11] = 7;
	
	//southwest forrest
	board[0][10] = 1;
	board[1][10] = 1;
	board[0][11] = 1;
	board[1][11] = 1;
	board[1][12] = 1;
	board[2][11] = 1;
	board[2][12] = 1;
	board[0][9] = 1;
	board[0][8] = 1;
	board[1][9] = 1;
	board[0][12] = 8;
	board[0][10] = 8;
	
	//southeast forrest
	board[10][11] = 1;
	board[10][12] = 1;
	board[11][9] = 1;
	board[11][10] = 1;
	board[11][11] = 1;
	board[11][12] = 1;
	board[12][8] = 1;
	board[12][9] = 1;
	board[12][10] = 1;
	board[12][11] = 1;
	board[12][12] = 8;
	board[12][10] = 8;
	
	//northern mountain range
	board[6][0] = 2;
	board[6][1] = 2;
	board[6][2] = 2;
	board[6][3] = 2;
	board[5][0] = 1;
	board[5][1] = 1;
	board[5][2] = 1;
	board[5][3] = 1;
	board[7][0] = 1;
	board[7][1] = 1;
	board[7][2] = 1;
	board[7][3] = 1;
	board[6][4] = 1;
	
	//central town
	board[5][5] = 8;
	board[5][7] = 8;
	board[7][5] = 8;
	board[7][7] = 8;
	board[6][6] = 7;
}

function mapStructures() { //Fills structureMap[] to represent building locations
	for (var i = 0; i < boardRows; i++) {
		structureMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			if (board[i][j] > 6) 
				structureMap[i][j] = -20;
			else if (board[i][j] > 3)
				structureMap[i][j] = 20;
			else 
				structureMap[i][j] = 0;
		}
	}
}

function generateSpace (x,y) { //Takes x,y cordinates on board and creates the appropriate space object holding image and location on the board
	var image = terrainImg[board[x][y]];
	var space = new component(spaceSize, spaceSize, image, toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "" + x + "," + y);
	return space;
}

function newPlayerUnit (xCord, yCord, unit) { //Creates a new unit for the player 
	//Visual component
	playerUnits[playerUnits.length] = new component(50, 50, units[unit].image, toPixel(xCord,globalOffsetX) + ((spaceSize-50)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-50)/2), "player", units[unit]);
	//Array location keeping track of whether unit has moved
	unitMoved[playerUnits.length-1] = 0;
	//Array location keeping track of unit health
	playerHP[playerHP.length] = new component("900 20px", "Courier New", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	//Array location keeping track of where this unit is on the board 
	entityLayer[xCord][yCord] = playerUnits.length-1;
}

function newEnemyUnit (xCord, yCord, unit) { //Same as newPlayerUnit but different arrays for enemy
	enemyUnits[enemyUnits.length] = new component(50, 50, units[unit].enemyImage, toPixel(xCord,globalOffsetX) + ((spaceSize-50)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-50)/2), "enemy", units[unit]);
	enemyUnitMoved[enemyUnits.length-1] = 0;
	enemyHP[enemyHP.length] = new component("900 20px", "Courier New", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	entityLayer[xCord][yCord] = ((enemyUnits.length-1) * -1)-2;
}

var gameArea = { //Sets up the "canvas" which is the window all game elements are drawn on, its unlikely any of this will ever need to be changed
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = boardX;
        this.canvas.height = boardY;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		this.interval = setInterval(updateGameArea, 20);
		window.addEventListener("mouseup", clicked); //creates listener for when mouse is clicked
		window.addEventListener('keydown', function (e) { //creates listener for when key is pressed
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = true;
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = false; 
        })
		
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type, unit) { //Components are elements that are represented visualy on the board
	//We want to be able to access all this information about our component by calling component.variable
	this.type = type;
    this.width = width;
    this.height = height;
	this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
	this.image = new Image();
	this.image.src = color;
    this.moveable = 0;
	this.text = unit
	
    this.update = function() { //every frame each component gets drawn onto the canvas with this function
		ctx = gameArea.context;
		
		if (this.type == "text") { //called if the component is a piece of text
			ctx.font = this.width + " " + this.height;
			if (color == "solidBlue") //different colors
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else 
				ctx.fillStyle = color;
			ctx.fillText(this.text, this.x, this.y);
		}
		
		else if (this.type == "square") { //called if the component is a square
			if (color == "blue") //more different colors (4th argument in rgba is opacity/transparecny with 0 being invisible and 1 being solid) 
				ctx.fillStyle = "rgba(69, 125, 211, 0.5)";
			else if (color == "red")
				ctx.fillStyle = "rgba(209, 21, 30, 0.5)";
			else if (color == "fog") 
				ctx.fillStyle = "rgba(89, 89, 89, 0.7)";
			else if (color == "solidBlue") 
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else 
				ctx.fillStyle = "rgba(212, 210, 144, 0.5)";
            ctx.fillRect(this.x, this.y, this.width, this.height);
		}
		
		else { //called if the component we're drawing is a picture
			ctx.drawImage(
			this.image, 
			this.x, 
			this.y,
			this.width, this.height);
			this.stats = unit;
		}
    }
	
    this.newPos = function() { //called when the component moves, adds its speed to its position (we need to include globalSpeed so that it moves when the board is scrolled)
		this.x = this.x + this.speedX + globalSpeedX;
		this.y = this.y + this.speedY + globalSpeedY;        
	}
} 

function updateGameArea() { //Called to draw each new frame on the canvas
    gameArea.clear(); //Erase everything we drew for the last frame
	
	if (gameArea.keys) //If a key is being pressed
		handleInput(); //then we let this guy handle it 
	
	for (var i = 0; i < boardRows; i++) { //We refresh all the images for our board spaces (everything has to be re-drawn each frame)
		arrayRefresh(spaces[i]);
	}

	arrayRefresh(movementHighlights); //Re-draw the squares showing where a unit can move
	
	arrayRefresh(attackHighlights); //Re-draw the squares showing where a unit can attack
	
	for (var i = 0; i < playerUnits.length; i++) { //For each of our units
		if (playerHP[i].text > 0) { //if its alive
			refresh(playerUnits[i]); //re-draw it
			refresh(playerHP[i]); //re-draw its HP
		}
	}
	
	for (var i = 0; i < enemyUnits.length; i++) { //Do the same for enemies
		if (enemyHP[i].text > 0) {
			refresh(enemyUnits[i]);
			refresh(enemyHP[i]);
		}
	}

	if (path != []) //If we're displaying a unit's movement path
		arrayRefresh(path); //re-draw each piece
	
	if (terrainCardOn) //If we're showing the terrain card
		arrayUpdate([terrainCard,terrainCardMove,terrainCardDef]); //re-draw each piece

	if (unitCardOn) //If we're showing the unit card 
		arrayUpdate([unitCard,unitCardAttack,unitCardDef,unitCardMove,unitCardSight]); //re-draw each piece 

	if (capturing && delay < 0) { //If we're capturing something and not waiting for something else to finish
		if (frame % 7 == 0) { //once every 7 frames (change this to speed up or slow down rate at which capture graphic ticks, more frames, slower ticks)
			if (capturing > 0) { //If we're not done
				captureCounter.text = captureCounter.text-1; //change the text
				if (captureCounter.text == Math.abs(captureVal)) { //If we just finished
					capturing = -2; //Note that we're no longer capturing anything
					delay = -2;	//and things no longer have to wait for it to be done
				}
			}
			else if (capturing < 0) {
				capturing++;
			}
		}
		captureCard.update(); //And don't forget to re-draw our visuals
		captureCounter.update();
		
		for (var i = 0; i < captureBar.length-(20-Math.abs(captureCounter.text)); i++) {
			captureBar[i].update(); //Redraw these ones too (the little bars that tick down)
		}
	}
	
	if (buildingUnit) { //If we're building a unit, re-draw our visuals
		factoryCard.update();
		for (var i = 0; i < factoryCardUnits.length; i++) {
			factoryCardUnitBackgrounds[i].update();
			factoryCardUnits[i].update();
			factoryCardText[i].update();
			factoryStatCard[i].update();
			for (var j = 0; j < factoryUnitStats[i].length; j++) {
				factoryUnitStats[i][j].update();
			}
		}
		goldText.update();
		incomeText.update();
	}
	
	if (delay < 0 && turnOver && !capturing) { //If we're not waiting for something to finish or capturing anything and the turn is over
		if (turnOver == 1) { //if its phase 1
			delay = 16; //wait a short bit
			turnOver = 2; //and then start phase 2
		}
		else if (turnOver == 2) { //if its phase 2
			endTurn(); //end the turn (this will turn on turnCard aka the "Day X" graphic)
			delay = 50; //wait almost a second
			turnOver = 3; //and then start phase 3
		}
		else {
			turnCardOn = false; //turn off the turn card
			turnNumber++; //another turn has passed
			turnText.text = "DAY " + turnNumber; //update the turn card to show this
			turnOver = 0; //and the turn is no longer over
			enemyTurn(); //now its the enemy turn
		}
	}
	
	if (delay < 0 && !arrayCompare(hpToSet,[])) { //if we're not waiting on anything and damage is waiting to be dealt
		hpToSet[0].text -= 1; //subtract 1 hp
		delay = 5; //and we're gonna wait a while before we do it again so that it looks fancier (increase to increase tick time on damage, decrease to decrease)
		if (hpToSet[0].text == hpToSet[1]) { //if we've done all the damage we need to do
			attacking = 0; //stop attacking
			delay = -2; //everything else doesn't have to wait anymore
			if (hpToSet[1] == 0) { //if we killed something move onto the space where it was
				moves = [[toSpace(enemyUnits[hpToSet[2]].x,globalOffsetX),toSpace(enemyUnits[hpToSet[2]].y,globalOffsetY)],[toSpace(playerUnits[selectedUnit].x,globalOffsetX),toSpace(playerUnits[selectedUnit].y,globalOffsetY)]];
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
				moveParams = [toSpace(playerUnits[selectedUnit].x,globalOffsetX),toSpace(playerUnits[selectedUnit].y,globalOffsetY),playerUnits[selectedUnit],moves.length-1];
				executeMoves();
			}
			unitMoved[selectedUnit] = 1; //after attacking set the unit as having been moved this turn
			playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].text.movedImage;
			refreshUnitMoved();
			hpToSet = [];
		}
	}
	
	if (turnCardOn) { //If we're showing the turn card
		turnCard.update(); //Re-draw it
		turnText.update();
	}	

	//fogUpdate();
	
	if (delay > 0) { //if theres a delay decrease it by one per frame
		delay--;
	}
	else if (delay == 0) { //this should probably be replaced, this is what makes units "step" accross the board instead of teleporting but its pretty bad
		delay--;
		executeMoves();
	}
	
	frame++;
}

function handleInput() { //called when a key is pressed
    if (gameArea.keys[83] && globalOffsetY > boardY - spaceSize*boardCols) { // if w is pressed scroll up
		globalSpeedY = -1*scrollSpeed;
		globalOffsetY -= scrollSpeed;
	}  
	else if (globalSpeedY == -1*scrollSpeed) {globalSpeedY = 0;} //if no longer pressing stop moving stop moving
    
	if (gameArea.keys[87] && globalOffsetY < 0) { //s scrolls down
		globalSpeedY = scrollSpeed;
		globalOffsetY += scrollSpeed;
	} 
	else if (globalSpeedY == scrollSpeed) {globalSpeedY = 0;}
	
	if (gameArea.keys[65] && globalOffsetX < 0) { //d scrolls right
		globalSpeedX = scrollSpeed;
		globalOffsetX += scrollSpeed;
	}
	else if (globalSpeedX == scrollSpeed) {globalSpeedX = 0;}
	
    if (gameArea.keys[68] && globalOffsetX > boardX - spaceSize*boardRows) { //a scrolls left
		globalSpeedX = -1*scrollSpeed;
		globalOffsetX -= scrollSpeed;
	} 
	else if (globalSpeedX == -1*scrollSpeed) {globalSpeedX = 0;}	
}

function refresh(given) { //runs newPos and update on given
	given.newPos();
	given.update();
}

function arrayRefresh(given) {	//runs refresh on all elements of array
	for (var i = 0; i < given.length; i++) {
		refresh(given[i]);
	}
}

function arrayUpdate(given) { //updates all elements of array
	for (var i = 0; i < given.length; i++) {
		given[i].update();
	}
}

function fogUpdate() { //Used for fog of war, half finished, not priority currently
	fogLayer = [];
	
	for (var i = 0; i < boardRows; i++) {
		fogMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			fogMap[i][j] = 1;
		}
	}
	
	if (unitCardOn) {
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-1] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	else if (terrainCardOn) {
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	
	for (var i = 0; i < fogMap.length; i++) {
		for (var j = 0; j < fogMap[0].length; j++) {
			defog(i,j);
			if (fogMap[i][j]) {
				fogLayer[fogLayer.length] = new component(spaceSize, spaceSize, "fog", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
			}
		}
	}
	
	for (var i = 0; i < fogLayer.length; i++) {
			fogLayer[i].update();
	}
}

function defog(i,j) {
	if (entityLayer[i][j] > -1) {
		fogMap[i][j] = 0;
		
		for (var k = 0; k < spaceOffset.length; k++) {
			fogMap[i + spaceOffset[k][0]][j + spaceOffset[k][1]] = 0;
		}
		//playerUnits[entityLayer[x][y]].stats.sight
	}
}

function clicked(event) { //called any time the user clicks
	if (delay < 0 && !capturing){
		var x = toSpace(event.clientX, globalOffsetX);
		var y = toSpace(event.clientY, globalOffsetY);
		if (buildingUnit) {
			if (x < 2 || y < 2 || y > 9 || x > 10){ //user clicks outside the building unit window
				buildingUnit = false; //close the building unit window
			}
			else if (x >= 3 && x <= 7 && y >= 3 && y <= 8) { //if they click a unit get it ready to build
				if (y < 5) {
					toBuild = 0;
				}
				else if (y < 7) {
					toBuild = 1;
				}
				else if (y < 9) {
					toBuild = 2;
				}
				
				if (gold >= units[toBuild].cost) { //if they have enough money to build the unit
					newPlayerUnit(factoryX, factoryY, toBuild); //build it
					unitMoved[unitMoved.length-1] = 1;
					gold -= units[toBuild].cost; //and take the money
					goldText.text = "Gold: " + gold;
					buildingUnit = false;
					playerUnits[playerUnits.length-1].image.src = playerUnits[playerUnits.length-1].text.movedImage;
				}
			}
		}
		else if (phase == 0 && !unitMoved[entityLayer[x][y]]) {
			if (entityLayer[x][y] > -1) {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				selectedUnit = entityLayer[x][y];
				highlightMoveable(x,y);	
				terrainCardOn = false;
				unitCardAttack.text = playerUnits[entityLayer[x][y]].stats.attack;
				unitCardDef.text = playerUnits[entityLayer[x][y]].stats.defense;
				unitCardMove.text = playerUnits[entityLayer[x][y]].stats.movement;
				unitCardSight.text = playerUnits[entityLayer[x][y]].stats.sight;
				unitCardOn = 1;
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none");
				phase++;
			}
			else if (entityLayer[x][y] < -1) {
				movementHighlights = [];
				terrainCardOn = false;
				unitCardAttack.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.attack;
				unitCardDef.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.defense;
				unitCardMove.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.movement;
				unitCardSight.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.sight;
				unitCardOn = 1;
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none");
			}
			else if (board[x][y] == 5) {
				factoryX = x;
				factoryY = y;
				buildingUnit = true;
			}
			else {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				terrainCardSpace = spaces[x][y];
				movementHighlights[0] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none");
				terrainCardOn = true;
				terrainCardMove.text = terrainCost[board[x][y]];
				terrainCardDef.text = terrainDef[board[x][y]];
			}
		}

		else if (entityLayer[x][y] > -1) {
			if (board[x][y] > 6 && entityLayer[x][y] == selectedUnit && !unitMoved[selectedUnit]) {
				captureStructure(x,y);
				playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].stats.movedImage;
				unitMoved[selectedUnit] = 1;
				refreshUnitMoved();
			}
			else if (entityLayer[x][y] == selectedUnit && !unitMoved[selectedUnit]) {
				alert(1);
			}
			clickedReset();
		}
		
		else if (phase == 1) {
			if (spaces[x][y].moveable == 1) {
				makeMoves(x,y,playerUnits[selectedUnit]);
				phase++;
			}
			else if (isAttackable(x,y)){
				var temp = isAttackable(x,y).destination;
				makeMoves(temp.x,temp.y,playerUnits[selectedUnit]);
				attackCheck = [x,y];
				phase++;
			}
			else {
				clickedReset();
			}
		}
		
		else if (phase == 2) {
			if (moves[0][0] == x && moves[0][1] == y){
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1];
				path = [];
				clearMoveable();
				unitCardOn = 0;
				executeMoves();
				if(structureMap[x][y] < 0) {
					captureStructure(x,y);
				}
				unitMoved[selectedUnit] = 1;
				refreshUnitMoved();
			}
			else if (spaces[x][y].moveable == 1) {
				phase = 1;
				moves = [];
				path = [];
				clicked(event);
			}
			else if (isAttackable(x,y) //space is attackable
					 && moves[0][0] == isAttackable(x,y).destination.x
					 && moves[0][1] == isAttackable(x,y).destination.y //and dest matches
					 && arrayCompare([x,y],attackCheck)) { //and clicked  same space
				makeAttack(entityLayer[x][y],selectedUnit);
				if (parseInt(enemyHP[(entityLayer[x][y]+2)*-1].text) <= 0) {
					killUnit(x,y);
				}
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1];
				path = [];
				clearMoveable();
				unitCardOn = 0;
				attacking = 1;
				executeMoves();
			}
			else {
				clickedReset();
			}
		}
	}
}

function makeAttack(tar, atk) {
	var target = tar;
	if (target < -1) {
		target = (target+2)*-1;
	}
	var attacker = playerUnits[atk].stats;
	var total = parseInt(enemyHP[target].text)-attacker.attack;
	hpToSet = [enemyHP[target], total, target];
}

function killUnit(x,y) {
	var unit = entityLayer[x][y];
	if (unit < -1) 
		unit = (unit+2)*-1;
	
	entityLayer[x][y] = -1;
}

function clickedReset() {
	unitCardOn = 0;
	clearMoveable();
	moves = [];
	path = [];
	phase = 0
	clicked(event);
}

function refreshUnitMoved () {
	var allMoved = true;
	for (var i = 0; i < unitMoved.length; i++) {
		if (!unitMoved[i]) {
			allMoved = false;
		}
	}
	
	if (allMoved) {
		for (var i = 0; i < unitMoved.length; i++) {
			unitMoved[i] = 0;
		}
		turnOver = 1;
	}
}

function endTurn() {
	for (var i = 0; i < unitMoved.length; i++) {
		playerUnits[i].image.src = playerUnits[i].stats.image;
	}
	
	turnCardOn = true;
	refreshIncome();
	gold += income;
	goldText.text = "Gold: " + gold;
}

function refreshIncome() {
	income = 0;
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
				if (board[i][j] > 3 && board[i][j] < 7)
					income+=100;
		}
	}
	incomeText.text = "Income: " + income;
}

function makeMoves (x,y,given) {
	var current;
	var selected = [0,0]
	moves.push([x,y]);

	while (!(arrayCompare(moves[moves.length-1],[toSpace(given.x, globalOffsetX),toSpace(given.y, globalOffsetY)]))) { //while the last position in the list of moves != the starting position
		current = -1;
		
		for (var i = 0; i < spaceOffset.length; i++) {
			if (moves[moves.length-1][0]+spaceOffset[i][0] >= 0 && moves[moves.length-1][1]+spaceOffset[i][1] >=0 && //make sure we don't check spaces off the board (@ array[-1])
				moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]] > current) {
				current = moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]];
				selected = spaceOffset[i];
			}
		}
		
		moves.push([moves[moves.length-1][0]+selected[0],moves[moves.length-1][1]+selected[1]]);
	}
	
	for (var i = 0; i < moves.length-1; i++) {
		drawPath(i);
	}
}

function drawPath(i) {
	/*if (i > 0) {
		if((moves[i-1][0] != moves[i][0]) && (moves[i+1][1] != moves[i][1])) {
			path[i] = new component(64, 64, "corner3.png", moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
		}
	}*/
	
	if (path[i] == undefined) {
		if (moves[i][1] != moves[i+1][1]) {
			path[i] = new component(10, 64, "verticalLine.png", (64-10)/2 + moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
		}
		else {
			path[i] = new component(64, 10, "horizontalLine.png", moves[i][0]*64 + globalOffsetX, (64-10)/2 + moves[i][1]*64 + globalOffsetY, "path");
		}
	}
}

function executeMoves () {
		if (delay == -2) {
			delay = 0;
		}
		moveActual(moveParams[0],moveParams[1],moveParams[2]);
		if (moveParams[3] >= 0) {
			moveParams[0] = moves[moveParams[3]][0];
			moveParams[1] = moves[moveParams[3]][1];
			moveParams[3] = moveParams[3]-1;
			delay = 9;
		}
		else if (moveParams[3] == -1) {
			moveOver();
		}
}

function moveActual(x,y,given) {
	given.x = toPixel(x,globalOffsetX) + ((spaceSize-given.width)/2);
	given.y = toPixel(y,globalOffsetY) + ((spaceSize-given.height)/2);
	if (given.type == "player") {
		playerHP[selectedUnit].x = toPixel(x,globalOffsetX) + 32;
		playerHP[selectedUnit].y = toPixel(y,globalOffsetY) + 57;
	}
	else {
		enemyHP[currentEnemy].x = toPixel(x,globalOffsetX) + 32;
		enemyHP[currentEnemy].y = toPixel(y,globalOffsetY) + 57;
	}
}

/*known bugs
only works for last one
*/

function enemyTurn () {
	var curr;
	for (var i = 0; i < enemyUnits.length; i++) {
		curr = enemyUnits[i];
		currentEnemy = i;
		moves = [[toSpace(curr.x,globalOffsetX)-1,toSpace(curr.y,globalOffsetY)],[toSpace(curr.x,globalOffsetX),toSpace(curr.y,globalOffsetY)]];
		entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
		moveParams = [toSpace(curr.x,globalOffsetX),toSpace(curr.y,globalOffsetY),curr,moves.length-1];
		executeMoves();
	}
}

/*known bugs
-will only work with friendly
-not affected by unit health
-if statment to change terrain wont work with enemy
-hp wont regen
*/

function captureStructure(x,y) {
	capturing = 1;
	captureCounter.text = Math.abs(structureMap[x][y]);
	captureVal = structureMap[x][y] + 10;//*(temp/Math.abs(temp));
	structureMap[x][y] = captureVal;
	if (board[x][y] > 8) {
		for (var i = 0; i < 20; i++) {
			captureBar[i] = new component(64, 10, "solidRed", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none"); //This is an awful clumsy way to do this but had problems w/ edit
		}
		captureCounter = new component("900 32px", "Courier New", "solidRed", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", captureCounter.text);
		//captureCard = new component(128, 320, "captureCard.png", boardX-spaceSize*2, boardY-spaceSize*5, "none", "none");
	}
	
	if (structureMap[x][y] >= 0) {
		if (board[x][y] > 8) {
			board[x][y] = board[x][y]-5;
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
		else if (board[x][y] > 6) {
			board[x][y] = board[x][y]-2;
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
	}
}

function moveOver() {
	entityLayer[moves[0][0]][moves[0][1]] = selectedUnit;
	moves = [];
	phase = 0;
	delay = -2;
	if (!attacking)
		playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].stats.movedImage;
}

function highlightMoveable(x, y) {
	getMoveable(x,y);

	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			if (moveableGrid[i][j] > -1 && !(i == x && j == y)) {
				if (entityLayer[i][j] > -2) {
					movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "blue", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
					spaces[i][j].moveable = 1;
				}
			}
		}
	}
	
	highlightAttackable();
}

function getMoveable(givenX,givenY) {
	var potentialMoveable = {movement: playerUnits[selectedUnit].stats.movement, x: givenX, y: givenY};
	moveableSpaces = [potentialMoveable];
	moveableGrid = [];
	expandMoveable();
	generateGrid();
}

function expandMoveable() {
	for (var i = 0; i < moveableSpaces.length; i++) {
		if (moveableSpaces[i].movement > 0) {
			for (var k = 0; k < spaceOffset.length; k++){
				currX = moveableSpaces[i].x + spaceOffset[k][0];
				currY = moveableSpaces[i].y + spaceOffset[k][1];
				if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space being checked is on the board
					&& moveableSpaces[i].movement - terrainCost[board[currX][currY]] >= 0 //unit has enough movement for terrain cost
					&& board[currX][currY] != 3 //space is not a river
					&& entityLayer[currX][currY] > -2 //space is not an enemy
					&& !(moveableSpaces[i].movement - terrainCost[board[currX][currY]] == 0 //if it's the last space of the move
						 && entityLayer[currX][currY] > -1) ){  //we can't move onto an ally unit
					newMoveable = {movement: moveableSpaces[i].movement - terrainCost[board[currX][currY]], x: currX, y: currY};
					moveableSpaces[moveableSpaces.length] = newMoveable;
				}
			}
		}
	}
}

function getAttackable() {
	for (var i = 0; i < moveableSpaces.length; i++) {
		for (var k = 0; k < spaceOffset.length; k++){
			currX = moveableSpaces[i].x + spaceOffset[k][0];
			currY = moveableSpaces[i].y + spaceOffset[k][1];
			var found = false;
			var currAtk;
			
			if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //space is on board
				&& entityLayer[currX][currY] < -1) {
				newAttackable = {destination: moveableSpaces[i], x: currX, y: currY};
				for (var l = 0; l < attackableSpaces.length; l++) {
					currAtk = attackableSpaces[l];
					if (currAtk.x == currX && currAtk.y == currY) {//we've found the attacking space already in array
						found = true;
						if (newAttackable.destination.movement > currAtk.destination.movement)  //move cost is less
							attackableSpaces[l] = newAttackable;
					}
				}
				if (!found) {//not found 
					attackableSpaces[attackableSpaces.length] = newAttackable; //add it
				}
			}
		}
	}
}

function highlightAttackable() {
	getAttackable();
	for (var i = 0; i < attackableSpaces.length; i++) {
		attackHighlights[attackHighlights.length] = new component(spaceSize, spaceSize, "red", toPixel(attackableSpaces[i].x,globalOffsetX), toPixel(attackableSpaces[i].y,globalOffsetY), "square", "none");
	}
}

function isAttackable(givenX, givenY) {
	for (var i = 0; i < attackableSpaces.length; i++) {
		if (attackableSpaces[i].x == givenX && attackableSpaces[i].y == givenY) {
			return attackableSpaces[i];
		}
	}
	return false;
}

function generateGrid() {
	var current = moveableSpaces[0];
	
	for (var q = 0; q <= boardRows; q++) {
		moveableGrid[q] = [];
		for (var w = 0; w <= boardCols; w++) {
			moveableGrid[q][w] = -1;
		}	
	}
	
	for (var i = 0; i < moveableSpaces.length; i++) {
		current = moveableSpaces[i];

		if (current.movement > (moveableGrid[current.x][current.y])) {
			moveableGrid[current.x][current.y] = current.movement;
		}
	}
}

function clearMoveable() {
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			movementHighlights = [];
			spaces[i][j].moveable = 0;
		}
	}
	attackableSpaces = [];
	attackHighlights = [];
}

function arrayCompare (array1, array2) { //array1 == array2 doesn't work the way you would hope so this does that (works for nested arrays)
	if (!array1 || !array2)
		return false;
	
	if (array1.length != array2.length)
		return false
	
	for (var i = 0; i < array1.length; i++) { //for each element of the array
		if (array1[i] instanceof Array && array2[i] instanceof Array) {
			if (!(arrayCompare(array1[i],array2[i]))) //if its a nested array recurse
				return false;
		}
		
		else if (!(array1[i] == array2[i])) //if they're not the same return false
			return false;
	}
	
	return true;
}

function toPixel (given,offset) {
	return given*spaceSize + offset;
}

function toSpace(given,offset) {
	return parseInt((given-offset)/spaceSize);
}

</script>

</body>
</html>
