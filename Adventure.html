<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()" oncontextmenu="return false">
<script>
//Variables used in the basic construction of the board
var spaceSize = 64; //size (in pixels) of each square on the board
var boardRows = 13; //# of rows our board will have
var boardCols = 13; //# of cols
var board = [];
var boardX;
var boardY;
var spaces = [];

var phase = 0; //Used to keep track of what player is doing with each click 
var delay = -2; //Used when we want to add in a real time delay (delay is 1 per frame so delay = 60 means 1 second IRL)
var frame; //keeps track of how many frames since the game began
var entityLayer = []; //Keeps track of whether a space is terrain (== -1), a friendly unit (> -1), or an enemy unit (< -1) (each unit in this array has a unique #)
//When accessing an enemy unit based on its entity layer #, access the correct position in enemyUnits[] with: 
//enemyUnits((entityLayer[x][y]+2)*-1)

//Variables used in movement and pathing functions
var moveableSpaces = [];
var newMoveable;
var moveableGrid = [];
var spaceOffset = [[1,0],[-1,0],[0,1],[0,-1]];
var currX;
var currY;
var path = [];
var pathX;
var pathY;
var moves = [];
var selectedUnit;
var moveParams = [];
var movementHighlights = [];
var unitMoved = [];

//Variables used for board scrolling (increase board rows &/or cols to test)
var globalOffsetX = 0;
var globalOffsetY = 0;
var globalSpeedX = 0;
var globalSpeedY = 0;
var scrollSpeed = 4; //To increase scrolls speed change this (not others)

//Variables used to track player units and hp
var playerUnits = [];
var playerHP = [];

//Variables used to track enemy units and hp
var enemyUnits = [];
var enemyHP = [];
var enemyUnitMoved = [];
var currentEnemy;

//Variables used to call click at a certain location
var forceClickX = 0;
var forceClickY = 0;

//Variables used in attack functions
var attackableSpaces = [];
var newAttackable;
var attackHighlights = [];
var attackCheck = [];
var attacking = 0;
var hpToSet = [];

//Variables to track turn and turn visuals
var turnNumber;
var turnText;
var turnCard;
var turnCardOn = false;
var turnOver = 0; 

//Arrays that hold/keep track of fog of war (not currently implemented)
var fogMap = [];
var fogLayer = [];

//Image for each type of space(/terrain)
var terrainImg = ["grass.png", "trees.png", "mountain.png","river.png",
"friendlyCastle.png","friendlyBarracks.png","friendlyVillage.png",
"barracks.png","village.png", 
"enemyCastle.png", "enemyBarracks.png","enemyVillage.png"];
//Movement cost of space types, currently stats for friendly, neutral, and enemy structures is the same
//But it might make sense to have them differ
var terrainCost = [1,2,3,"X", //terrain
1,1,1, //friendly structures
1,1, //neutral structures
1,1,1]; //enemy structures
var terrainDef = [1,2,3,"X", //Same as above except defense scores
4,3,2,
3,2,
4,3,2];

//Variables used for the unit card (window that shows terrain stats when you click on it)
var terrainCard;
var terrainCardMove;
var terrainCardDef;
var terrainCardOn = false;

//Variables used for the unit card (window that shows a units stats when you click on it)
var unitCard;
var unitCardAttack;
var unitCardDef;
var unitCardMove;
var unitCardSight;
var unitCardOn = 0;

//Variables used in capturing and capturing display
var structureMap = [];
var capturing = 0; 
var captureCounter; 
var captureBar = [];
var captureCard;
var capturing = 0;
var captureVal;

//Variables used for building units and the unit building display
var factoryCard;
var factoryCardUnits = [];
var factoryCardUnitBackgrounds = [];
var factoryCardText = [];
var factoryStatCard = [];
var factoryUnitStats = [];
var factoryX;
var factoryY;
var toBuild;
var buildingUnit = false;

//Variables used for money and income
var gold;
var goldText;
var income; 
var incomeText;

//Variables used in enemy turn
var currentEnemy;
var curr;
var enemiesMoving;

//These objects store the stats for each unit, as well as the display images, and their cost to produce
var infantry = {attack: 3, defense: 3, movement: 3, sight: 3, image: "soldier.png", movedImage: "soldierMoved.png", enemyImage: "soldierEnemy.png", name: "Light Infantry", cost: 300};
var heavyInfantry = {attack: 4, defense: 5, movement: 2, sight: 2, image: "knight.png", movedImage: "knightMoved.png", enemyImage: "knightEnemy.png", name: "Heavy Infantry", cost: 600};
var cavalry = {attack: 5, defense: 2, movement: 4, sight: 4, image: "cavalry.png", movedImage: "cavalryMoved.png", enemyImage: "cavalryEnemy.png", name: "Cavalry", cost: 1000};
var archer = {attack: 4, defense: 1, movement: 3, sight: 3, name: "Archer"};

var units = [infantry, heavyInfantry, cavalry];
//current attack function doesn't support long range (yet)
//var units = [infantry, heavyInfantry, cavalry, archer];

function startGame() { //called when the game starts
	frame = 0; 
	turnNumber = 1;
	gold = 500;
	enemiesMoving = 0;
	
	if (boardRows * spaceSize > window.innerWidth) //if the board is wider than the screen
		boardX = parseInt(window.innerWidth/spaceSize)*spaceSize; //make the display area however many squares we can fit on the screen 
	else 														  //if not all the spaces fit on screen they can be seen by scrolling
		boardX = boardRows * spaceSize; //otherwise we show the whole board
			
	if (boardCols * spaceSize > window.innerHeight) //same as above except but for vertical
		boardY = parseInt(window.innerHeight/spaceSize)*spaceSize;
	else 
		boardY = boardCols * spaceSize;

	
	
	mapTerrain(); //lays out the map terrain
	mapStructures(); //fills out structureMap[] to represent where buildings are
	
	//Fills out 2D arrays representing the terrain (spaces[]) and location of units (entityLayer[])
	for (var i = 0; i < boardRows; i++) {
		spaces[i] = [];
		entityLayer[i] = [];
		for (var j = 0; j < boardCols; j++) {
				spaces[i][j] = generateSpace(i,j); //creates a space object for each location on the board holding the image and pixel location on the canvas
				entityLayer[i][j] = -1; //We haven't added units so the entity layer is a empty
		}
	}
	
	newPlayerUnit(2, 4, 1); //creates a new player unit at board space x,y of unit type u where the function reads newPlayerUnit(x,y,u)
	newPlayerUnit(2, 2, 2);
	newPlayerUnit(4, 4, 0);
	newPlayerUnit(3, 3, 0);
	
	newEnemyUnit(10, 4, 1); //same as newPlayer unit but for enemies, may condense both into a single function "newUnit" later on
	newEnemyUnit(6, 4, 0);
	newEnemyUnit(9, 3, 0);
	newEnemyUnit(10, 2, 2);
	
	//This section is the decleration of all the visual elements we will need to render on the canvas
	
	//The terrain card is a window that appears when a piece of terrain is selected, that displays its stats, these are the visual components that make up the card
	terrainCard = new component(64, 128, "terrainCard.png", boardX-spaceSize, boardY-spaceSize*2, "none", "none");
	terrainCardMove = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	terrainCardDef = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "3");
	
	//The unit card is the terrain card but for a unit
	unitCard = new component(128, 128, "unitCard.png", boardX-spaceSize*2, boardY-spaceSize*2, "none", "none");
	unitCardAttack = new component("900 32px", "Courier New", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 48, "text", "1");
	unitCardDef = new component("900 32px", "Courier New", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 103, "text", "2");
	unitCardMove = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	unitCardSight = new component("900 32px", "Courier New", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "4");
	
	//Visual components for showing the capture progress graphic
	for (var i = 0; i < 20; i++) {
		captureBar[i] = new component(64, 10, "solidGrey", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none");
	}
	captureCounter = new component("900 32px", "Courier New", "solidGrey", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", "4");
	captureCard = new component(128, 320, "captureCard.png", boardX-spaceSize*2, boardY-spaceSize*5, "none", "none");
	
	//The factory card is a window that shows money, income, units that can be built, and stats about those units, these are the visual components that make up the card
	factoryCard = new component(spaceSize*9, spaceSize*8, "factoryCard.png", boardX-spaceSize*11, boardY-spaceSize*11, "none", "none");
	goldText = new component("900 32px", "Courier New", "black", toPixel(3,0), toPixel(2,45), "text", "Gold: " + gold);
	incomeText = new component("900 32px", "Courier New", "black", toPixel(7,0), toPixel(2,45), "text", income);
	for (var i = 0; i < units.length; i++) {
		factoryCardUnits[i] = new component(50, 50, units[i].image, toPixel(3,0) + ((spaceSize-50)/2), toPixel(i*2 + 3,0) + ((spaceSize-50)/2), "player", units[i]);
		factoryCardUnitBackgrounds[i] = new component(64, 64, "factoryCardUnitBackground.png", toPixel(3,0), toPixel(i*2 + 3,0), "none", "none");
		factoryCardText[i] = new component("900 32px", "Courier New", "black", toPixel(4,10), toPixel(i*2 + 3,42), "text", units[i].name);
		factoryStatCard[i] = new component(256, 64, "factoryStatCard.png", toPixel(3,0), toPixel(i*2 + 4,0), "none", "none");
		factoryUnitStats[i] = [];
		factoryUnitStats[i][0] = new component("900 32px", "Courier New", "white", toPixel(3,35), toPixel(i*2 + 4,45), "text", units[i].attack);
		factoryUnitStats[i][1] = new component("900 32px", "Courier New", "white", toPixel(4,30), toPixel(i*2 + 4,45), "text", units[i].movement);
		factoryUnitStats[i][2] = new component("900 32px", "Courier New", "white", toPixel(5,25), toPixel(i*2 + 4,45), "text", units[i].defense);
		factoryUnitStats[i][3] = new component("900 32px", "Courier New", "white", toPixel(6,27), toPixel(i*2 + 4,45), "text", units[i].sight);
		factoryUnitStats[i][4] = new component("900 32px", "Courier New", "black", toPixel(7,10), toPixel(i*2 + 4,45), "text", "Cost: " + units[i].cost);
	}
	
	//The turn card is displayed at the end of each turn and shows what turn it is
	turnText = new component("bold 68px", "Courier New", "black", (boardCols-2.9)*spaceSize/2, boardRows*spaceSize/2, "text", "DAY " + turnNumber);
	turnCard = new component(spaceSize*5, spaceSize*2, "turnCard.png", (boardCols-4.8)*spaceSize/2, (boardRows-2.6)*spaceSize/2, "none", "none");
	
	refreshIncome(); //Sets income text to be correct based on # of friendly structures
	
	gameArea.start(); //Starts the game
}


function mapTerrain() { //edit this to edit terrain (aka place mountain, change forrest to river ect.)
	for (var i = 0; i < boardRows; i++) {
		board[i] = [];
		for (var j = 0; j < boardCols; j++) {
			board[i][j] = 0;
		}
	}
	
	//player's base
	board[1][1] = 4;
	board[1][2] = 5;
	board[2][1] = 5;
	board[1][3] = 6;
	board[3][1] = 6;
	
	//enemy base
	board[11][1] = 9;
	board[11][2] = 10;
	board[10][1] = 10;
	board[11][3] = 11;
	board[9][1] = 11;
	
	//southern island
	board[4][12] = 3;
	board[4][11] = 3;
	board[4][10] = 3;
	board[8][12] = 3;
	board[8][11] = 3;
	board[8][10] = 3;
	board[5][9] = 3;
	board[7][9] = 3;
	
	board[5][12] = 8;
	board[7][12] = 8;
	board[6][11] = 7;
	
	//southwest forrest
	board[0][10] = 1;
	board[1][10] = 1;
	board[0][11] = 1;
	board[1][11] = 1;
	board[1][12] = 1;
	board[2][11] = 1;
	board[2][12] = 1;
	board[0][9] = 1;
	board[0][8] = 1;
	board[1][9] = 1;
	board[0][12] = 8;
	board[0][10] = 8;
	
	//southeast forrest
	board[10][11] = 1;
	board[10][12] = 1;
	board[11][9] = 1;
	board[11][10] = 1;
	board[11][11] = 1;
	board[11][12] = 1;
	board[12][8] = 1;
	board[12][9] = 1;
	board[12][10] = 1;
	board[12][11] = 1;
	board[12][12] = 8;
	board[12][10] = 8;
	
	//northern mountain range
	board[6][0] = 2;
	board[6][1] = 2;
	board[6][2] = 2;
	board[6][3] = 2;
	board[5][0] = 1;
	board[5][1] = 1;
	board[5][2] = 1;
	board[5][3] = 1;
	board[7][0] = 1;
	board[7][1] = 1;
	board[7][2] = 1;
	board[7][3] = 1;
	board[6][4] = 1;
	
	//central town
	board[5][5] = 8;
	board[5][7] = 8;
	board[7][5] = 8;
	board[7][7] = 8;
	board[6][6] = 7;
}

function mapStructures() { //Fills structureMap[] to represent building locations
	for (var i = 0; i < boardRows; i++) {
		structureMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			if (board[i][j] > 6) 
				structureMap[i][j] = -20;
			else if (board[i][j] > 3)
				structureMap[i][j] = 20;
			else 
				structureMap[i][j] = 0;
		}
	}
}

function generateSpace (x,y) { //Takes x,y cordinates on board and creates the appropriate space object holding image and location on the board
	var image = terrainImg[board[x][y]];
	var space = new component(spaceSize, spaceSize, image, toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "" + x + "," + y);
	return space;
}

function newPlayerUnit (xCord, yCord, unit) { //Creates a new unit for the player 
	//Visual component
	playerUnits[playerUnits.length] = new component(50, 50, units[unit].image, toPixel(xCord,globalOffsetX) + ((spaceSize-50)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-50)/2), "player", units[unit]);
	//Array location keeping track of whether unit has moved
	unitMoved[playerUnits.length-1] = units[unit].movement;
	//Array location keeping track of unit health
	playerHP[playerHP.length] = new component("900 20px", "Courier New", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	//Array location keeping track of where this unit is on the board 
	entityLayer[xCord][yCord] = playerUnits.length-1;
}

function newEnemyUnit (xCord, yCord, unit) { //Same as newPlayerUnit but different arrays for enemy
	enemyUnits[enemyUnits.length] = new component(50, 50, units[unit].enemyImage, toPixel(xCord,globalOffsetX) + ((spaceSize-50)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-50)/2), "enemy", units[unit]);
	enemyUnitMoved[enemyUnits.length-1] = units[unit].movement;
	enemyHP[enemyHP.length] = new component("900 20px", "Courier New", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	entityLayer[xCord][yCord] = ((enemyUnits.length-1) * -1)-2;
}

var gameArea = { //Sets up the "canvas" which is the window all game elements are drawn on, its unlikely any of this will ever need to be changed
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = boardX;
        this.canvas.height = boardY;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		this.interval = setInterval(updateGameArea, 20);
		window.addEventListener("mouseup", clicked); //creates listener for when mouse is clicked
		window.addEventListener('keydown', function (e) { //creates listener for when key is pressed
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = true;
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = false; 
        })
		
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type, unit) { //Components are elements that are represented visualy on the board
	//We want to be able to access all this information about our component by calling component.variable
	this.type = type;
    this.width = width;
    this.height = height;
	this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
	this.image = new Image();
	this.image.src = color;
    this.moveable = 0;
	this.text = unit
	
    this.update = function() { //every frame each component gets drawn onto the canvas with this function
		ctx = gameArea.context;
		
		if (this.type == "text") { //called if the component is a piece of text
			ctx.font = this.width + " " + this.height;
			if (color == "solidBlue") //different colors
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else if (color == "solidGold")
				ctx.fillStyle = "rgba(255,215,0,1)";
			else 
				ctx.fillStyle = color;
			ctx.fillText(this.text, this.x, this.y);
		}
		
		else if (this.type == "square") { //called if the component is a square
			if (color == "blue") //more different colors (4th argument in rgba is opacity/transparecny with 0 being invisible and 1 being solid) 
				ctx.fillStyle = "rgba(69, 125, 211, 0.5)";
			else if (color == "red")
				ctx.fillStyle = "rgba(209, 21, 30, 0.5)";
			else if (color == "fog") 
				ctx.fillStyle = "rgba(89, 89, 89, 0.7)";
			else if (color == "solidBlue") 
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else 
				ctx.fillStyle = "rgba(212, 210, 144, 0.5)";
            ctx.fillRect(this.x, this.y, this.width, this.height);
		}
		
		else { //called if the component we're drawing is a picture
			ctx.drawImage(
			this.image, 
			this.x, 
			this.y,
			this.width, this.height);
			this.stats = unit;
		}
    }
	
    this.newPos = function() { //called when the component moves, adds its speed to its position (we need to include globalSpeed so that it moves when the board is scrolled)
		this.x = this.x + this.speedX + globalSpeedX;
		this.y = this.y + this.speedY + globalSpeedY;        
	}
} 

function updateGameArea() { //Called to draw each new frame on the canvas
    gameArea.clear(); //Erase everything we drew for the last frame
	
	if (gameArea.keys) //If a key is being pressed
		handleInput(); //then we let this guy handle it 
	
	for (var i = 0; i < boardRows; i++) { //We refresh all the images for our board spaces (everything has to be re-drawn each frame)
		arrayRefresh(spaces[i]);
	}

	arrayRefresh(movementHighlights); //Re-draw the squares showing where a unit can move
	
	arrayRefresh(attackHighlights); //Re-draw the squares showing where a unit can attack
	
	for (var i = 0; i < playerUnits.length; i++) { //For each of our units
		if (playerHP[i].text > 0) { //if its alive
			refresh(playerUnits[i]); //re-draw it
			refresh(playerHP[i]); //re-draw its HP
		}
	}
	
	for (var i = 0; i < enemyUnits.length; i++) { //Do the same for enemies
		if (enemyHP[i].text > 0) {
			refresh(enemyUnits[i]);
			refresh(enemyHP[i]);
		}
	}

	if (path != []) //If we're displaying a unit's movement path
		arrayRefresh(path); //re-draw each piece
	
	if (terrainCardOn) //If we're showing the terrain card
		arrayUpdate([terrainCard,terrainCardMove,terrainCardDef]); //re-draw each piece

	if (unitCardOn) //If we're showing the unit card 
		arrayUpdate([unitCard,unitCardAttack,unitCardDef,unitCardMove,unitCardSight]); //re-draw each piece 

	if (capturing && delay < 0) { //If we're capturing something and not waiting for something else to finish
		if (frame % 7 == 0) { //once every 7 frames (change this to speed up or slow down rate at which capture graphic ticks, more frames, slower ticks)
			if (capturing > 0) { //If we're not done
				captureCounter.text = captureCounter.text-1; //change the text
				if (captureCounter.text == Math.abs(captureVal)) { //If we just finished
					capturing = -2; //Note that we're no longer capturing anything
					delay = -2;	//and things no longer have to wait for it to be done
					unitMoved[selectedUnit] = 0; //after capturing set the unit as having been moved this turn
					playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].text.movedImage;
				}
			}
			else if (capturing < 0) {
				capturing++;
			}
		}
		captureCard.update(); //And don't forget to re-draw our visuals
		captureCounter.update();
		
		for (var i = 0; i < captureBar.length-(20-Math.abs(captureCounter.text)); i++) {
			captureBar[i].update(); //Redraw these ones too (the little bars that tick down)
		}
	}
	
	if (buildingUnit) { //If we're building a unit, re-draw our visuals
		factoryCard.update();
		for (var i = 0; i < factoryCardUnits.length; i++) {
			factoryCardUnitBackgrounds[i].update();
			factoryCardUnits[i].update();
			factoryCardText[i].update();
			factoryStatCard[i].update();
			for (var j = 0; j < factoryUnitStats[i].length; j++) {
				factoryUnitStats[i][j].update();
			}
		}
		goldText.update();
		incomeText.update();
	}
	
	if (delay < 0 && turnOver && !capturing) { //If we're not waiting for something to finish or capturing anything and the turn is over
		if (turnOver == 1) { //if its phase 1
			delay = 16; //wait a short bit
			turnOver = 2; //and then start phase 2
		}
		else if (turnOver == 2) { //if its phase 2
			endTurn(); //end the turn (this will turn on turnCard aka the "Day X" graphic)
			delay = 30; //wait half a second
			turnOver = 3; //and then start phase 3
		}
		else {
			turnCardOn = false; //turn off the turn card
			turnNumber++; //another turn has passed
			turnText.text = "DAY " + turnNumber; //update the turn card to show this
			turnOver = 0; //and the turn is no longer over
			enemyTurn(); //now its the enemy turn NOTE: temporarily disabled
		}
	}
	
	if (delay < 0 && !arrayCompare(hpToSet,[])) { //if we're not waiting on anything and damage is waiting to be dealt
		hpToSet[0].text -= 1; //subtract 1 hp
		delay = 5; //and we're gonna wait a while before we do it again so that it looks fancier (increase to increase tick time on damage, decrease to decrease)
		if (hpToSet[0].text == hpToSet[1]) { //if we've done all the damage we need to do
			attacking = 0; //stop attacking
			delay = -2; //everything else doesn't have to wait anymore
			if (hpToSet[1] <= 0) { //if we killed something move onto the space where it was
				moves = [[toSpace(enemyUnits[hpToSet[2]].x,globalOffsetX),toSpace(enemyUnits[hpToSet[2]].y,globalOffsetY)],[toSpace(playerUnits[selectedUnit].x,globalOffsetX),toSpace(playerUnits[selectedUnit].y,globalOffsetY)]];
				entityLayer[moves[0][0]][moves[0][1]] = -1;
				moveParams = [toSpace(playerUnits[selectedUnit].x,globalOffsetX),toSpace(playerUnits[selectedUnit].y,globalOffsetY),playerUnits[selectedUnit],moves.length-1];
				executeMoves();
			}
			unitMoved[selectedUnit] = 0; //after attacking set the unit as having been moved this turn
			playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].text.movedImage;
			hpToSet = [];
		}
	}
	
	if (delay < 0 && enemiesMoving && currentEnemy < enemyUnits.length) {
		executeMoves();
	}
	else if (currentEnemy == enemyUnits.length)
		enemiesMoving = 0;
	
	if (turnCardOn) { //If we're showing the turn card
		turnCard.update(); //Re-draw it
		turnText.update();
	}	

	//fogUpdate();
	
	if (delay > 0) { //if theres a delay decrease it by one per frame
		delay--;
	}
	else if (delay == 0) { //this should probably be replaced, this is what makes units "step" accross the board instead of teleporting but its pretty bad
		delay--;
		executeMoves();
	}
	
	frame++;
}

function handleInput() { //called when a key is pressed
	if (gameArea.keys[83] && globalOffsetY > boardY - spaceSize*boardCols) { // if w is pressed scroll up
		globalSpeedY = -1*scrollSpeed;
		globalOffsetY -= scrollSpeed;
	}  
	else if (globalSpeedY == -1*scrollSpeed) {globalSpeedY = 0;} //if no longer pressing stop moving stop moving
    
	if (gameArea.keys[87] && globalOffsetY < 0) { //s scrolls down
		globalSpeedY = scrollSpeed;
		globalOffsetY += scrollSpeed;
	} 
	else if (globalSpeedY == scrollSpeed) {globalSpeedY = 0;}
	
	if (gameArea.keys[65] && globalOffsetX < 0) { //d scrolls right
		globalSpeedX = scrollSpeed;
		globalOffsetX += scrollSpeed;
	}
	else if (globalSpeedX == scrollSpeed) {globalSpeedX = 0;}
	
    if (gameArea.keys[68] && globalOffsetX > boardX - spaceSize*boardRows) { //a scrolls left
		globalSpeedX = -1*scrollSpeed;
		globalOffsetX -= scrollSpeed;
	} 
	else if (globalSpeedX == -1*scrollSpeed) {globalSpeedX = 0;}

	if ((gameArea.keys[13] || gameArea.keys[32]) && delay < 0 && !enemiesMoving) {
		turnOver = 2;
	}
}

function refresh(given) { //runs newPos and update on given
	given.newPos();
	given.update();
}

function arrayRefresh(given) {	//runs refresh on all elements of array
	for (var i = 0; i < given.length; i++) {
		refresh(given[i]);
	}
}

function arrayUpdate(given) { //updates all elements of array
	for (var i = 0; i < given.length; i++) {
		given[i].update();
	}
}

function fogUpdate() { //Used for fog of war, half finished, not priority currently
	fogLayer = [];
	
	for (var i = 0; i < boardRows; i++) {
		fogMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			fogMap[i][j] = 1;
		}
	}
	
	if (unitCardOn) {
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-1] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	else if (terrainCardOn) {
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	
	for (var i = 0; i < fogMap.length; i++) {
		for (var j = 0; j < fogMap[0].length; j++) {
			defog(i,j);
			if (fogMap[i][j]) {
				fogLayer[fogLayer.length] = new component(spaceSize, spaceSize, "fog", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
			}
		}
	}
	
	for (var i = 0; i < fogLayer.length; i++) {
			fogLayer[i].update();
	}
}

function defog(i,j) {
	if (entityLayer[i][j] > -1) {
		fogMap[i][j] = 0;
		
		for (var k = 0; k < spaceOffset.length; k++) {
			fogMap[i + spaceOffset[k][0]][j + spaceOffset[k][1]] = 0;
		}
		//playerUnits[entityLayer[x][y]].stats.sight
	}
}

function clicked(event) { //called any time the user clicks
	if (delay < 0 && !capturing){	
		if (forceClickX) { //For when we call clicked in a specific location
			var x = forceClickX
			forceClickX = 0;
		}
		else 
			var x = toSpace(event.clientX, globalOffsetX);
		if (forceClickY) {
			var y = forceClickY;
			forceClickY = 0;
		}
		else 
			var y = toSpace(event.clientY, globalOffsetY);

		if (buildingUnit) { //if the building unit window is open
			if (x < 2 || y < 2 || y > 9 || x > 10){ //user clicks outside the building unit window
				buildingUnit = false; //close the building unit window
			}
			else if (x >= 3 && x <= 7 && y >= 3 && y <= 8) { //if they click a unit get it ready to build
				if (y < 5) {
					toBuild = 0;
				}
				else if (y < 7) {
					toBuild = 1;
				}
				else if (y < 9) {
					toBuild = 2;
				}
				
				if (gold >= units[toBuild].cost && entityLayer[factoryX][factoryY] == -1) { //if they have enough money to build the unit
					newPlayerUnit(factoryX, factoryY, toBuild); //build it
					unitMoved[unitMoved.length-1] = 0;
					gold -= units[toBuild].cost; //and take the money
					goldText.text = "Gold: " + gold;
					buildingUnit = false;
					playerUnits[playerUnits.length-1].image.src = playerUnits[playerUnits.length-1].text.movedImage;
				}
			}
		}
		else if (phase == 0) {
			movementHighlights = []; //clear off existing movement highlights
			if (entityLayer[x][y] > -1 && unitMoved[entityLayer[x][y]]) { //if clicked on a player unit that hasn't moved this turn
				selectedUnit = entityLayer[x][y]; //the unit clicked on becomes the selected unit
				highlightMoveable(x,y);	//this function will draw the squares that represent where the unit can move
				terrainCardOn = false; //stop showing the terrain card
				unitCardAttack.text = playerUnits[selectedUnit].stats.attack; //set each element of the unit card
				unitCardDef.text = playerUnits[selectedUnit].stats.defense;
				unitCardMove.text = playerUnits[selectedUnit].stats.movement;
				unitCardSight.text = playerUnits[selectedUnit].stats.sight;
				unitCardOn = 1; //start showing the unit card
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none"); //highlight the selected unit
				phase++;
			}
			else if (entityLayer[x][y] < -1) { //if clicked on an enemy unit
				movementHighlights = []; //stop showing any movemnt highlights 
				terrainCardOn = false; //stop showing the terrain card
				unitCardAttack.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.attack; //set each element of the unit card
				unitCardDef.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.defense;
				unitCardMove.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.movement;
				unitCardSight.text = enemyUnits[(entityLayer[x][y]+2)*-1].stats.sight;
				unitCardOn = 1; //start showing the unit card
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none"); //highlight the selected unit
			}
			else if (board[x][y] == 5 && entityLayer[x][y] == -1) { //if clicked on a friendly barracks/factory and no unit there
				factoryX = x; //remember where the factory is for later
				factoryY = y;
				buildingUnit = true; //and show the factory window
			}
			else { //if clicked on terrain
				movementHighlights[0] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none"); //highlight it 
				unitCardOn = false;
				terrainCardOn = true; //turn on the terrain card
				terrainCardMove.text = terrainCost[board[x][y]]; //set each element of the terrain card
				terrainCardDef.text = terrainDef[board[x][y]];
			}
		}

		else if (entityLayer[x][y] > -1) { //if its a player unit and player already clicked once
			if (board[x][y] > 6 && entityLayer[x][y] == selectedUnit && !unitMoved[selectedUnit]) { //if its an enemy structure & player clicked on the selected unit & it hasnt moved
				captureStructure(x,y);
				playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].stats.movedImage; //set the unit as having been moved
				unitMoved[selectedUnit] = 0;
			}
			clickedReset(); //reset everything when we're done
		}
		
		else if (phase == 1) {
			if (spaces[x][y].moveable == 1) { //if clicked on a space unit can move to
				makeMoves(x,y,playerUnits[selectedUnit]); //map/plan the move the player selected, and draw the path
				phase++;
			}
			else if (isAttackable(x,y)){ //if clicked on an attackable space
				var temp = isAttackable(x,y).destination; //remember where the unit will move to make the attack
				makeMoves(temp.x,temp.y,playerUnits[selectedUnit]); //that's the units destination , so map it with makeMoves, and draw the path the unit will take
				attackCheck = [x,y]; //remeber where the unit being attacked is
				phase++;
				if (unitMoved[selectedUnit] == -1) //if the unit has used all its move
					clicked(event);
			}
			else { //if they made a click that isn't attack or move act like its phase 0 because it means they want to do something else
				clickedReset();
			}
		}
		
		else if (phase == 2) { //if clicked twice
			if (moves[0][0] == x && moves[0][1] == y){ //if clicked on the same move destination space that was mapped on previous click, move is confirmed
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1; //the space the unit moved off of no longer contains a unit
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1]; //get the first move ready for execute moves
				path = []; //no longer need to show the path, since move is about to happen
				clearMoveable(); //no longer need to show moveable squares for same reason
				unitCardOn = 0;
				executeMoves(); //move has been confirmed, so make it
				if(structureMap[x][y] < 0) { //if moving onto a structure, capture it
					captureStructure(x,y);
				}
				unitMoved[selectedUnit] = unitMoved[selectedUnit] - (moves.length-1); //mark the unit as having moved
				if (unitMoved[selectedUnit] == 0 && checkAttackable(x,y)) { //if the unit has used its moves but can attack
					unitMoved[selectedUnit] = -1;
					forceClickX = moves[0][0];
					forceClickY = moves[0][1];
				}
			}
			else if (spaces[x][y].moveable == 1) { //if clicked on a space the unit can move onto, but not the one pathed to in the last phase, re-do that phase with new destination
				phase = 1;
				moves = [];
				path = [];
				clicked(event);
			}
			else if (isAttackable(x,y) //if clicked on space that can be attacked 
			&& moves[0][0] == isAttackable(x,y).destination.x //and the destination matches
			&& moves[0][1] == isAttackable(x,y).destination.y 
			&& arrayCompare([x,y],attackCheck)) { //and clicked same space as last time, confirming it
				makeAttack(entityLayer[x][y],selectedUnit); //make the attack 
				if (parseInt(enemyHP[(entityLayer[x][y]+2)*-1].text) <= 0) { //if the attack killed the unit
					entityLayer[x][y] = -1; //then there's no longer a unit there
				}
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1; //NOTE! Not sure what this is could be causing bugs, will review tomorrow am
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1];
				path = []; //no longer need to display path, move highlights, or unit card
				clearMoveable();
				unitCardOn = 0;
				attacking = 1; //we're attacking 
				executeMoves(); //make the moves
			}
			else {
				clickedReset();
			}
		}
	}
}

function highlightMoveable(x, y) {
	getMoveable(x,y,selectedUnit); //create a 2D array representing the board, that contains info on whether we can move to a square for each location on the board

	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) { //for each square on the board that is moveable, highlight it with a semi-transparent blue square
			if (moveableGrid[i][j] > -1 && !(i == x && j == y) && entityLayer[i][j] > -2) { //if our grid says it can be moved too, and also theres no enemy there
					movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "blue", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none"); //highlight the square
					spaces[i][j].moveable = 1; //and mark it as moveable
			}
		}
	}
	
	highlightAttackable(); //now highlight squares we can attack
}

function getMoveable(givenX,givenY, unit) {
	if (unit > -1) //if its a friendly unit
		var potentialMoveable = {movement: unitMoved[unit], x: givenX, y: givenY}; //create our starting point, the units location
	else //if enemy unit
		var potentialMoveable = {movement: enemyUnits[(unit*-1)-2].stats.movement, x: givenX, y: givenY};
	moveableSpaces = [potentialMoveable]; //make our list of spaces we can move to just our starting point
	moveableGrid = []; //reset moveableGrid to empty
	expandMoveable(); //fills moveableSpaces[] with a space object(x cord, y cord, and movement cost to get there) for every square this unit could move to
	generateGrid(); //makes a grid representing the movement cost to get to each moveable space (aka moveableSpaces[] is all routes, moveableGrid[] is only the "fastest" ones)
}

function expandMoveable() {
	for (var i = 0; i < moveableSpaces.length; i++) { //run this loop until we get to the end of moveableSpaces (which grows during the loop until unit's movement is all used)
		if (moveableSpaces[i].movement > 0) { //if the unit can get to the space we're currently looking at and still have some movement left
			for (var k = 0; k < spaceOffset.length; k++){ //for each of the four cardinal directions
				currX = moveableSpaces[i].x + spaceOffset[k][0]; //set current space to the one in that  direction
				currY = moveableSpaces[i].y + spaceOffset[k][1];
				if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space being checked is on the board
				&& moveableSpaces[i].movement - terrainCost[board[currX][currY]] >= 0 //unit has enough movement for terrain cost
				&& board[currX][currY] != 3 //space is not a river
				&& entityLayer[currX][currY] > -2 //space is not an enemy
				&& !(moveableSpaces[i].movement - terrainCost[board[currX][currY]] == 0 && entityLayer[currX][currY] > -1) ){ //if it's not both the last space of the move and the location of an ally (this prevents the move on top of an ally by attacking bug)
					newMoveable = {movement: moveableSpaces[i].movement - terrainCost[board[currX][currY]], x: currX, y: currY}; //create a new space object representing this one (movement is how much move the unit will have left if it moves here)
					moveableSpaces[moveableSpaces.length] = newMoveable; //and add it to our list of moveable spaces
				}
			}
		}
	}
}

function generateGrid() {
	var current = moveableSpaces[0]; //start with the first space in our list of spaces we can mvoe to
	
	for (var q = 0; q <= boardRows; q++) { //create a 2D array that's a grid the same dimensions as the board
		moveableGrid[q] = [];
		for (var w = 0; w <= boardCols; w++) {
			moveableGrid[q][w] = -1; //filled with -1's
		}	
	}
	
	for (var i = 0; i < moveableSpaces.length; i++) { //for every space on the grid
		current = moveableSpaces[i];
		if (current.movement > (moveableGrid[current.x][current.y])) //if we can reach the same space using less movement, or this space is moveable and hasn't been set yet
			moveableGrid[current.x][current.y] = current.movement; //set the movement cost of this location in the grid equal to the one stored in that space
	}
}

function highlightAttackable() {
	getAttackable(); //create a 2D array representing the board, that contains info on what spaces can be attacked, and where the unit should move when attacking
	for (var i = 0; i < attackableSpaces.length; i++) { //for each space we can attack
		attackHighlights[attackHighlights.length] = new component(spaceSize, spaceSize, "red", toPixel(attackableSpaces[i].x,globalOffsetX), toPixel(attackableSpaces[i].y,globalOffsetY), "square", "none"); //highlight it
	}
}

function getAttackable() {
	for (var i = 0; i < moveableSpaces.length; i++) { //for every space that we can move to
		for (var k = 0; k < spaceOffset.length; k++){ //for each of the cardinal directions
			currX = moveableSpaces[i].x + spaceOffset[k][0]; //set our current space to the space in that direction
			currY = moveableSpaces[i].y + spaceOffset[k][1];
			var found = false;
			var currAtk;
			if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space is on board
			&& entityLayer[currX][currY] < -1 //and there's an enemy there
			&& !(entityLayer[moveableSpaces[i].x][moveableSpaces[i].y] > -1 //and our destination won't have a friendly unit (aka no unit stacking)
				&& (entityLayer[moveableSpaces[i].x][moveableSpaces[i].y] != selectedUnit))) { //make sure we don't count the moving unit as a friendly unit in the way
				newAttackable = {destination: moveableSpaces[i], x: currX, y: currY}; //create a new attackable object (destination is the square moved to adjacent to the target being attacked)
				for (var l = 0; l < attackableSpaces.length; l++) { //for each object in the array of all attackable spaces
					currAtk = attackableSpaces[l]; //set that one to our current
					if (currAtk.x == currX && currAtk.y == currY) {//if our current is at the same location as the new one
						found = true; //remember that we found that space 
						if (newAttackable.destination.movement > currAtk.destination.movement)  //if the new move cost is less than the current one
							attackableSpaces[l] = newAttackable; //replace the current with the new
					}
				}
				if (!found) {//if we didn't find that location anywhere in the array
					attackableSpaces[attackableSpaces.length] = newAttackable; //add it
				}
			}
		}
	}
}

function checkAttackable(givenX, givenY) {
	for (var k = 0; k < spaceOffset.length; k++){ //for each of the four cardinal directions
		currX = givenX + spaceOffset[k][0]; //set current space to the one in that  direction
		currY = givenY + spaceOffset[k][1];
		if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space being checked is on the board
		&& entityLayer[currX][currY] < -1) {//space is an enemy
			return true; //we found a space that can be attacked
		}
	}
	return false;
}

/*known bugs
-will only work with friendly
-not affected by unit health
-if statment to change terrain wont work with enemy
-hp wont regen
*/

function captureStructure(x,y) {
	capturing = 1; //remember that we're capturing something
	captureCounter.text = Math.abs(structureMap[x][y]); //Set our # display for capturing 
	captureVal = structureMap[x][y] + 10; //establish how much progress we need to make twoards capturing NOTE: this should not be hardcoded as 10, will not work with enemy
	structureMap[x][y] = captureVal; //change structureMap to reflect the progress we're going to make later on
	if (board[x][y] > 8) { //if the structure is an enemy one, make the graphics red
		for (var i = 0; i < 20; i++) {
			captureBar[i] = new component(64, 10, "solidRed", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none"); //This is an awful clumsy way to do this but had problems w/ edit
		}
		captureCounter = new component("900 32px", "Courier New", "solidRed", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", captureCounter.text);
	}
	else if (board[x][y] > 6) { //if the structure is a neutral one, make the graphics grey 
		for (var i = 0; i < 20; i++) {
			captureBar[i] = new component(64, 10, "solidGrey", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none");
		}
		captureCounter = new component("900 32px", "Courier New", "solidGrey", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", captureCounter.text);
	}
	
	if (structureMap[x][y] >= 0) { //if we finished capturing it 
		if (board[x][y] > 8) { //if its enemy 
			board[x][y] = board[x][y]-5; //change to friendly
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
		else if (board[x][y] > 6) {//if its neutral
			board[x][y] = board[x][y]-2; //change to friendly
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
	}
}

function clickedReset() { //resets everything to do with clicked to prepare for new click
	unitCardOn = 0;
	clearMoveable();
	moves = [];
	path = [];
	phase = 0
	clicked(event);
}

function makeMoves (x,y,given) { //should probably be renamed, works backwards to find quickest path to destination and turns that path into a square-by-square list of moves
	var current;
	var selected = [0,0]
	moves.push([x,y]); //make the space clicked on the first element of the array of moves we'll make

	while (!(arrayCompare(moves[moves.length-1],[toSpace(given.x, globalOffsetX),toSpace(given.y, globalOffsetY)]))) { //while the last position in the list of moves != the starting position (this method starts at the destination and works backwards)
		current = -1; //reset current
		
		for (var i = 0; i < spaceOffset.length; i++) { //look at the 4 squares adjacent to the last one in our list of moves, finds the one with the most leftover movement, and puts it on the end of the list (ensures units will always pathfind fastest route) 
			if (moves[moves.length-1][0]+spaceOffset[i][0] >= 0 && moves[moves.length-1][1]+spaceOffset[i][1] >=0 && //makes sure we don't check spaces off the board (@ array[-1])
				moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]] > current) { //if the movement leftover for the square in the chosen direction is more than the current highest
				current = moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]]; //make that the new current
				selected = spaceOffset[i]; //and remember where the square is
			}
		}
		
		moves.push([moves[moves.length-1][0]+selected[0],moves[moves.length-1][1]+selected[1]]); //whichever one we found to be fastest we put on the end of the list
	}
	
	if (!enemiesMoving) { //enemies don't need path ui
		for (var i = 0; i < moves.length-1; i++) { //for each move on our list
			drawPath(i); //assign the right image for when we display the path
		}
	}
}

function drawPath(i) {
	/*if (i > 0) {    Need corner graphics to do this part
		if((moves[i-1][0] != moves[i][0]) && (moves[i+1][1] != moves[i][1])) {
			path[i] = new component(64, 64, "corner3.png", moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
		}
	}*/
	
	if (path[i] == undefined) { //if we haven't assigned this one yet
		if (moves[i][1] != moves[i+1][1]) //if the y values of this move and the last are different
			path[i] = new component(10, 64, "verticalLine.png", (64-10)/2 + moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path"); //vertical path
		else
			path[i] = new component(64, 10, "horizontalLine.png", moves[i][0]*64 + globalOffsetX, (64-10)/2 + moves[i][1]*64 + globalOffsetY, "path"); //horizonatl path
	}
}

function executeMoves () { //gets called by update once its made the first move (very hobo)
		if (delay == -2) { //reset the delay
			delay = 0;
		}
		moveActual(moveParams[0],moveParams[1],moveParams[2]); //make the current move
		if (moveParams[3] >= 0) { //if we have more moves to go, get the next move ready, working backwards through the moves array (1st element is destination, last is start)
			moveParams[0] = moves[moveParams[3]][0];
			moveParams[1] = moves[moveParams[3]][1];
			moveParams[3] = moveParams[3]-1; //and we have one less move remaining
			delay = 9; //amount of time (9/60 seconds) between each move
		}
		else if (moveParams[3] == -1) { //if we've made our last move
			moveOver(); //end the move
		}
}

function moveActual(x,y,given) { //actually moves the unit's image on the screen
	given.x = toPixel(x,globalOffsetX) + ((spaceSize-given.width)/2); //move the unit
	given.y = toPixel(y,globalOffsetY) + ((spaceSize-given.height)/2);
	if (given.type == "player") { //move its hp display to stay with it
		playerHP[selectedUnit].x = toPixel(x,globalOffsetX) + 32;
		playerHP[selectedUnit].y = toPixel(y,globalOffsetY) + 57;
	}
	else { //enemy units use different hp array
		enemyHP[currentEnemy].x = toPixel(x,globalOffsetX) + 32;
		enemyHP[currentEnemy].y = toPixel(y,globalOffsetY) + 57;
	}
}

function moveOver() {
	if (!enemiesMoving)
		entityLayer[moves[0][0]][moves[0][1]] = selectedUnit; //update the units position in the entity layer
	else //if its an enemy that's moving
		entityLayer[moves[0][0]][moves[0][1]] = (currentEnemy*-1)-2; //do the same
	delay = -2;
	phase = 0;
	if (forceClickX == moves[0][0] && forceClickY == moves[0][1]) //this is the case where a unit has moved and now will want to attack
		clicked(event);
	moves = []; //reset everything
	if (!enemiesMoving && !unitMoved[selectedUnit]) //if we don't need to make an attack after this
		playerUnits[selectedUnit].image.src = playerUnits[selectedUnit].stats.movedImage; //make our unit show that its done moving 
	if (enemiesMoving) 
		enemyMove();
}

function isAttackable(givenX, givenY) { //returns whether space can be attacked 
	for (var i = 0; i < attackableSpaces.length; i++) { //look through all the spaces that can be attacked 
		if (attackableSpaces[i].x == givenX && attackableSpaces[i].y == givenY) { //see if we can find the space we were given
			return attackableSpaces[i]; //if so return it
		}
	}
	return false; //otherwise return false
}

function makeAttack(tar, atk) {
	var target = tar;
	if (target < -1) { //if it's an enemy unit
		target = (target+2)*-1; //we need to do this to convert entityLayer # into array position #
	}
	var attacker = playerUnits[atk].stats; //need stats for attacking unit
	var total = parseInt(enemyHP[target].text)-attacker.attack; //calculates how much health unit will have after attack NOTE: here's where to add more complex math (def, terrain def, ect)
	hpToSet = [enemyHP[target], total, target]; //remember what the hp should be set to (the number we just calculated), and which unit's hp will be set
}

function endTurn() {
	for (var i = 0; i < unitMoved.length; i++) {
		unitMoved[i] = playerUnits[i].stats.movement; //set it so none of them have moved
		playerUnits[i].image.src = playerUnits[i].stats.image; //change all the unit images back to unmoved 
	}
	turnCardOn = true; //turn on turn card
	refreshIncome(); //update income and gold
	gold += income;
	goldText.text = "Gold: " + gold;
}

function refreshIncome() { //checks how many buildings the player controls and adds them up to get income
	income = 0;
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
				if (board[i][j] > 3 && board[i][j] < 7)
					income+=100;
		}
	}
	incomeText.text = "Income: " + income;
}

/*known bugs
only works for last one
*/

function enemyTurn () { //Called when the enemy turn starts
	currentEnemy = -1;
	enemiesMoving = 1;
	clearMoveable(); //make sure we clear all the player movement UI before we start moving
	moves = [];
	path = [];
	phase = 0
	enemyMove();
}

function enemyMove () { //called each time an enemy makes a move (once per space)
	currentEnemy++;
	curr = enemyUnits[currentEnemy];

	getMoveable(toSpace(curr.x,globalOffsetX),toSpace(curr.y,globalOffsetY),(currentEnemy*-1)-2);
	var destination = getDestination();
	makeMoves(destination[0],destination[1],curr); 
	entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1; //the space the unit moved off of no longer contains a unit
	moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],curr,moves.length-1]; //get the first move ready for execute moves
	clearMoveable(); //no longer need to show moveable squares for same reason
	executeMoves();
}

function getDestination() {
	var dest = [6,11];
	var currDest = [moveableSpaces[0].x,moveableSpaces[0].y];
	
	for (var i = 0; i < moveableSpaces.length; i++) {
		if (Math.abs(moveableSpaces[i].x - dest[0]) + Math.abs(moveableSpaces[i].y - dest[1]) <
			Math.abs(currDest[0] - dest[0]) + Math.abs(currDest[1] - dest[1])) {
				currDest = [moveableSpaces[i].x,moveableSpaces[i].y];
		}
	}
	return currDest;
}

function clearMoveable() { //resets all the array used in movement functions
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			movementHighlights = [];
			spaces[i][j].moveable = 0;
		}
	}
	attackableSpaces = [];
	attackHighlights = [];
}

function arrayCompare (array1, array2) { //array1 == array2 doesn't work the way you would hope, so this does that (checks if elements are same & same order, works for nested arrays)
	if (!array1 || !array2)
		return false;
	
	if (array1.length != array2.length)
		return false
	
	for (var i = 0; i < array1.length; i++) { //for each element of the array
		if (array1[i] instanceof Array && array2[i] instanceof Array) {
			if (!(arrayCompare(array1[i],array2[i]))) //if its a nested array recurse
				return false;
		}
		
		else if (!(array1[i] == array2[i])) //if they're not the same return false
			return false;
	}
	
	return true;
}

function toPixel (given,offset) { //takes a location on the board and converts it to a location in pixels
	return given*spaceSize + offset;
}

function toSpace(given,offset) { //takes a location in pixels and converts it into a location on the board
	return parseInt((given-offset)/spaceSize);
}

</script>

</body>
</html>
