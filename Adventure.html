<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()" oncontextmenu="return false">
<script>

var spaces = [];
var boardX = 896;
var boardY = 896;
var phase = 0;
var board = [];
var moveableSpaces = [];
var moveableGrid = [];
var spaceOffset = [[1,0],[-1,0],[0,1],[0,-1]];
var newMoveable;
var currX;
var currY;
var path = [];
var pathX;
var pathY;
var playerUnits = [];
var playerHP = [];
var moves = [];
var spaceSize = 64;
var boardRows = 18;
var boardCols = 18;
var selectedUnit;
var entityLayer = [];
var globalSpeedX = 0;
var globalSpeedY = 0;
var scrollSpeed = 4;
var globalOffsetX = 0;
var globalOffsetY = 0;
var moveParams = [];
var delay = -2;

var terrainImg = ["grass.png", "trees.png", "mountain.png"];
var terrainCost = [1,2,3];
var terrainDef = [1,2,3];

var terrainCard;
var terrainCardMove;
var terrainCardDef;
var terrainCardSpace;
var terrainCardOn = false;

var unitCard;
var unitCardAttack;
var unitCardDef;
var unitCardMove;
var unitCardSight;
var unitCardOn = false;

var infantry = {attack: 3, defense: 3, movement: 3};
var heavyInfantry = {attack: 4, defense: 5, movement: 2};
var cavalry = {attack: 5, defense: 2, movement: 4};
var archer = {attack: 4, defense: 1, movement: 3};

var units = [infantry, heavyInfantry, cavalry, archer];

var movementHighlights = [];

function startGame() {
	mapTerrain();
	
	for (var i = 0; i < boardRows; i++) {
		spaces[i] = [];
		entityLayer[i] = [];
		for (var j = 0; j < boardCols; j++) {
				spaces[i][j] = generateSpace(i,j);
				entityLayer[i][j] = -1;
		}
	}
	
	newPlayerUnit(33, 49, "knight.png", 2, 5, 1);
	newPlayerUnit(50, 50, "cavalry.png", 2, 2, 2);
	newPlayerUnit(50, 50, "roman.png", 4, 7, 0);
	newPlayerUnit(50, 50, "roman.png", 7, 7, 0);
	newPlayerUnit(50, 50, "archer.png", 1, 1, 3);
	
	terrainCard = new component(64, 128, "terrainCard.png", boardX-spaceSize, boardY-spaceSize*2, "none", "none");
	terrainCardMove = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	terrainCardDef = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "3");
	
	unitCard = new component(128, 128, "unitCard.png", boardX-spaceSize*2, boardY-spaceSize*2, "none", "none");
	unitCardAttack = new component("900 32px", "Arial", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 48, "text", "1");
	unitCardDef = new component("900 32px", "Arial", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 103, "text", "2");
	unitCardMove = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	unitCardSight = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "4");
	
	gameArea.start();
}

function newPlayerUnit (sizeX, sizeY, img, xCord, yCord, unit) {
	playerUnits[playerUnits.length] = new component(sizeX, sizeY, img, toPixel(xCord,globalOffsetX) + ((spaceSize-sizeX)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-sizeY)/2), "player", units[unit]);
	playerHP[playerHP.length] = new component("900 20px", "Arial", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	entityLayer[xCord][yCord] = playerUnits.length-1;
}

function mapTerrain() {
	for (var i = 0; i < boardRows; i++) {
		board[i] = [];
		for (var j = 0; j < boardCols; j++) {
			board[i][j] = 0;
		}
	}
	
	board[3][3] = 1;
	board[3][4] = 1;
	board[4][3] = 1;
	board[4][4] = 1;
	board[4][5] = 1;
	
	board[8][8] = 1;
	board[8][9] = 1;
	board[9][8] = 1;
	
	//board[5][0] = 2;
	board[5][1] = 2;
	//board[5][2] = 2;
	board[5][3] = 2;
	
}

function generateSpace (x,y) {
	var image = getImage(x,y);
	var space = new component(spaceSize, spaceSize, image, toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "" + x + "," + y);
	return space;
}

var gameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = boardX;
        this.canvas.height = boardY;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		this.interval = setInterval(updateGameArea, 20);
		window.addEventListener("mouseup", clicked);
		window.addEventListener('keydown', function (e) {
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = true;
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = false; 
        })
		
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type, unit) {
	this.type = type;
    this.width = width;
    this.height = height;
	this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
	this.image = new Image();
	this.image.src = color;
    this.moveable = false;
	this.text = unit
	
    this.update = function() {
		ctx = gameArea.context;
		
		if (this.type == "text") {
			ctx.font = this.width + " " + this.height;
			ctx.fillStyle = color;
			ctx.fillText(this.text, this.x, this.y);
		}
		
		else if (this.type == "square") {
			if (color == "blue")
				ctx.fillStyle = "rgba(69, 125, 211, 0.5)";
			else 
				ctx.fillStyle = "rgba(212, 210, 144, 0.5)";
            ctx.fillRect(this.x, this.y, this.width, this.height);
		}
		
		else {
			ctx.drawImage(this.image, 
			this.x, 
			this.y,
			this.width, this.height);
			this.stats = unit;
		}
    }
	
    this.newPos = function() {
		this.x = this.x + this.speedX + globalSpeedX;
		this.y = this.y + this.speedY + globalSpeedY;        
	}
} 

function updateGameArea() {
    gameArea.clear();
	
	if (gameArea.keys) {
		handleInput();
	}
	
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			spaces[i][j].newPos();
			spaces[i][j].update();
		}
	}

	if (movementHighlights != []) {
		for (var i = 0; i < movementHighlights.length; i++) {
				movementHighlights[i].newPos();
				movementHighlights[i].update();
		}
	}
	
	for (var i = 0; i < playerUnits.length; i++) {
			playerUnits[i].newPos();
			playerUnits[i].update();
	}
	
	for (var i = 0; i < playerHP.length; i++) {
			playerHP[i].newPos();
			playerHP[i].update();
	}
	
	if (path != []) {
		for (var i = 0; i < path.length; i++) {
			path[i].newPos();
			path[i].update();
		}
	}
	
	if (terrainCardOn) {
		terrainCard.update();
		terrainCardMove.update();
		terrainCardDef.update();
	}
	
	if (unitCardOn) {
	unitCard.update();
	unitCardAttack.update();
	unitCardDef.update();
	unitCardMove.update();
	unitCardSight.update();
	}
	
	
	if (delay > 0) {
		delay--;
	}
	else if (delay == 0) {
		delay--;
		executeMoves();
	}
}

function handleInput() {
    if (gameArea.keys[83] && globalOffsetY > boardY - spaceSize*boardRows) { // w key
		globalSpeedY = -1*scrollSpeed;
		globalOffsetY -= scrollSpeed;
	}  
	else if (globalSpeedY == -1*scrollSpeed) {globalSpeedY = 0;} //if keyup stop moving
    
	if (gameArea.keys[87] && globalOffsetY < 0) { //s
		globalSpeedY = scrollSpeed;
		globalOffsetY += scrollSpeed;
	} 
	else if (globalSpeedY == scrollSpeed) {globalSpeedY = 0;}
	
	if (gameArea.keys[65] && globalOffsetX < 0) { //d
		globalSpeedX = scrollSpeed;
		globalOffsetX += scrollSpeed;
	}
	else if (globalSpeedX == scrollSpeed) {globalSpeedX = 0;}
	
    if (gameArea.keys[68] && globalOffsetX > boardX - spaceSize*boardCols) { //a
		globalSpeedX = -1*scrollSpeed;
		globalOffsetX -= scrollSpeed;
	} 
	else if (globalSpeedX == -1*scrollSpeed) {globalSpeedX = 0;}
	
}

function clicked(event) {
	if (delay < 0) {
		var x = toSpace(event.clientX, globalOffsetX);
		var y = toSpace(event.clientY, globalOffsetY);
			
		if (phase == 0) {
			
			if (entityLayer[x][y] > -1) {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				//spaces[x][y].image.src = getImage(x,y,1);
				selectedUnit = entityLayer[x][y];
				highlightMoveable(x,y);	
				terrainCardOn = false;
				unitCardAttack.text = playerUnits[entityLayer[x][y]].stats.attack;
				unitCardDef.text = playerUnits[entityLayer[x][y]].stats.defense;
				unitCardMove.text = playerUnits[entityLayer[x][y]].stats.movement;
				//unitCardSight.text = playerUnits[entityLayer[x][y]].stats.sight;
				unitCardOn = true;
				phase++;
			}
			
			else {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				
				terrainCardSpace = spaces[x][y];
				movementHighlights[0] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none");
				terrainCardOn = true;
				terrainCardMove.text = terrainCost[board[x][y]];
				terrainCardDef.text = terrainDef[board[x][y]];
			}
		}

		else if (entityLayer[x][y] > -1) {
			clickedReset();
		}
		
		else if (phase == 1) {
			if (spaces[x][y].moveable) {
				makeMoves(x,y,playerUnits[selectedUnit]);
				phase++;
			}
			else {
				clickedReset();
			}
		}
		
		else if (phase == 2) {
			if (moves[0][0] == x && moves[0][1] == y){
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1];
				path = [];
				clearMoveable();
				unitCardOn = false;
				executeMoves();
			}
			else if (spaces[x][y].moveable) {
				phase = 1;
				moves = [];
				path = [];
				clicked(event);
			}
			else {
				clickedReset();
			}
		}
	}
}

function clickedReset() {
	unitCardOn = false;
	clearMoveable();
	moves = [];
	path = [];
	phase = 0
	clicked(event);
}

function makeMoves (x,y,given) {
	var current;
	var selected = [0,0]
	moves.push([x,y]);

	while (!(arrayCompare(moves[moves.length-1],[toSpace(given.x, globalOffsetX),toSpace(given.y, globalOffsetY)]))) { //while the last position in the list of moves != the starting position
		current = -1;
		
		for (var i = 0; i < spaceOffset.length; i++) {
			if (moves[moves.length-1][0]+spaceOffset[i][0] >= 0 && moves[moves.length-1][1]+spaceOffset[i][1] >=0 && //make sure we don't check spaces off the board (@ array[-1])
				moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]] > current) {
				current = moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]];
				selected = spaceOffset[i];
			}
		}
		
		moves.push([moves[moves.length-1][0]+selected[0],moves[moves.length-1][1]+selected[1]]);
	}
	
	for (var i = 0; i < moves.length-1; i++) {
		drawPath(i);
	}
}

function arrayCompare (array1, array2) {
	if (!array1 || !array2) {
		return false;
	}
	
	if (array1.length != array2.length) {
		return false
	}
	
	for (var i = 0; i < array1.length; i++) {
		if (array1[i] instanceof Array && array2[i] instanceof Array) {
			if (!(arrayCompare(array1[i],array2[i]))) {
				return false;
			}
		}
		
		else if (!(array1[i] == array2[i])) {
			return false;
		}
	}
	
	return true;
}

function drawPath(i) {
	if (moves[i][1] != moves[i+1][1]) {
		path[i] = new component(10, 64, "verticalLine.png", (64-10)/2 + moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
	}
	else {
		path[i] = new component(64, 10, "horizontalLine.png", moves[i][0]*64 + globalOffsetX, (64-10)/2 + moves[i][1]*64 + globalOffsetY, "path");
	}
	
}

function executeMoves () {
		moveActual(moveParams[0],moveParams[1],moveParams[2]);
		if (moveParams[3] >= 0) {
			moveParams[0] = moves[moveParams[3]][0];
			moveParams[1] = moves[moveParams[3]][1];
			moveParams[3] = moveParams[3]-1;
			
			if (delay == -2) {
				delay = 0;
			}
			else {
				delay = 9;
			}
		}
		else if (moveParams[3] == -1) {
			moveOver();
		}
}

function moveActual(x,y,given) {
	given.x = toPixel(x,globalOffsetX) + ((spaceSize-given.width)/2);
	given.y = toPixel(y,globalOffsetY) + ((spaceSize-given.height)/2);
	playerHP[selectedUnit].x = toPixel(x,globalOffsetX) + 32;
	playerHP[selectedUnit].y = toPixel(y,globalOffsetY) + 57;
}

function moveOver() {
	entityLayer[moves[0][0]][moves[0][1]] = selectedUnit;
	moves = [];
	phase = 0;
	delay = -2;
}

function highlightMoveable(x, y) {
	getMoveable(x,y);

	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			if (moveableGrid[i][j] > -1 && !(i == x && j == y)) {
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "blue", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
				spaces[i][j].moveable = true;
			}
		}
	}
}

function getMoveable(givenX,givenY) {
	var potentialMoveable = {movement: playerUnits[selectedUnit].stats.movement, x: givenX, y: givenY};
	moveableSpaces = [potentialMoveable];
	moveableGrid = [];
	expandMoveable();
	generateGrid();
}

function expandMoveable() {
	for (var i = 0; i < moveableSpaces.length; i++) {
		if (moveableSpaces[i].movement > 0) {
			for (var k = 0; k < spaceOffset.length; k++){
				currX = moveableSpaces[i].x + spaceOffset[k][0];
				currY = moveableSpaces[i].y + spaceOffset[k][1];
				if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space being checked is on the board
					&& moveableSpaces[i].movement - terrainCost[board[currX][currY]] >= 0){
					newMoveable = {movement: moveableSpaces[i].movement - terrainCost[board[currX][currY]], x: currX, y: currY};
					moveableSpaces[moveableSpaces.length] = newMoveable;
				}
			}
		}
	}
}

function generateGrid() {
	var current = moveableSpaces[0];
	
	for (var q = 0; q <= boardRows; q++) {
		moveableGrid[q] = [];
		for (var w = 0; w <= boardCols; w++) {
			moveableGrid[q][w] = -1;
		}	
	}
	
	for (var i = 0; i < moveableSpaces.length; i++) {
		current = moveableSpaces[i];

		if (current.movement > (moveableGrid[current.x][current.y])) {
			moveableGrid[current.x][current.y] = current.movement;
		}
	}
}

function clearMoveable() {
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			movementHighlights = [];
			spaces[i][j].moveable = false;
		}
	}
}

function getImage(x,y,category) {
	return terrainImg[board[x][y]];
}

function toPixel (given,offset) {
	return given*spaceSize + offset;
}

function toSpace(given,offset) {
	return parseInt((given-offset)/spaceSize);
}

</script>

</body>
</html>
