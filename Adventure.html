<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}

</style>
</head>
<body onload="startGame()" oncontextmenu="return false">
<script>

var spaceSize = 64;
var boardRows = 13;
var boardCols = 13;
var spaces = [];
var boardX;
var boardY;
var phase = 0;
var board = [];
var moveableSpaces = [];
var moveableGrid = [];
var spaceOffset = [[1,0],[-1,0],[0,1],[0,-1]];
var newMoveable;
var currX;
var currY;
var path = [];
var pathX;
var pathY;
var playerUnits = [];
var playerHP = [];
var enemyUnits = [];
var enemyHP = [];
var moves = [];
var selectedUnit;
var entityLayer = [];
var globalSpeedX = 0;
var globalSpeedY = 0;
var scrollSpeed = 4;
var globalOffsetX = 0;
var globalOffsetY = 0;
var moveParams = [];
var delay = -2;

var fogMap = [];
var fogLayer = [];

var terrainImg = ["grass.png", "trees.png", "mountain.png","river.png",
"friendlyCastle.png","friendlyBarracks.png","friendlyVillage.png",
"barracks.png","village.png", 
"enemyCastle.png", "enemyBarracks.png","enemyVillage.png"];
var terrainCost = [1,2,3,50,1,1,1,1,1,1,1,1];
var terrainDef = [1,2,3,1,4,3,2,3,2,4,3,2];

var terrainCard;
var terrainCardMove;
var terrainCardDef;
var terrainCardSpace;
var terrainCardOn = false;

var structureMap = [];
var capturing = 0; 
var captureCounter; 
var captureBar = [];
var captureCard;
var capturing = 0;
var captureVal;

var factoryCard;
var factoryCardUnits = [];
var factoryCardUnitBackgrounds = [];
var factoryCardText = [];
var factoryStatCard = [];
var factoryUnitStats = [];
var buildingUnit = false;

var unitCard;
var unitCardAttack;
var unitCardDef;
var unitCardMove;
var unitCardSight;
var unitCardOn = 0;

var infantry = {attack: 3, defense: 3, movement: 3, sight: 3, image: "soldier.png", name: "Light Infantry"};
var heavyInfantry = {attack: 4, defense: 5, movement: 2, sight: 2, image: "knight.png", name: "Heavy Infantry"};
var cavalry = {attack: 5, defense: 2, movement: 4, sight: 4, image: "cavalry.png", name: "Cavalry"};
var archer = {attack: 4, defense: 1, movement: 3, sight: 3, name: "Archer"};

var units = [infantry, heavyInfantry, cavalry];
//var units = [infantry, heavyInfantry, cavalry, archer];

var movementHighlights = [];

var frame;

function startGame() {
	frame = 0; 
	
	if (boardRows * spaceSize > window.innerWidth) 
		boardX = parseInt(window.innerWidth/spaceSize)*spaceSize;
	else 
		boardX = boardRows * spaceSize;
		
	if (boardCols * spaceSize > window.innerHeight)
		boardY = parseInt(window.innerHeight/spaceSize)*spaceSize;
	else 
		boardY = boardCols * spaceSize;

	mapTerrain();
	mapStructures(); 
	
	for (var i = 0; i < boardRows; i++) {
		spaces[i] = [];
		entityLayer[i] = [];
		for (var j = 0; j < boardCols; j++) {
				spaces[i][j] = generateSpace(i,j);
				entityLayer[i][j] = -1;
		}
	}
	
	newPlayerUnit(2, 5, 1);
	newPlayerUnit(2, 2, 2);
	newPlayerUnit(4, 4, 0);
	newPlayerUnit(3, 3, 0);
	
	terrainCard = new component(64, 128, "terrainCard.png", boardX-spaceSize, boardY-spaceSize*2, "none", "none");
	terrainCardMove = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	terrainCardDef = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "3");
	
	unitCard = new component(128, 128, "unitCard.png", boardX-spaceSize*2, boardY-spaceSize*2, "none", "none");
	unitCardAttack = new component("900 32px", "Arial", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 48, "text", "1");
	unitCardDef = new component("900 32px", "Arial", "white", boardX-spaceSize*2 + 37, boardY-spaceSize*2 + 103, "text", "2");
	unitCardMove = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 48, "text", "3");
	unitCardSight = new component("900 32px", "Arial", "white", boardX-spaceSize + 35, boardY-spaceSize*2 + 103, "text", "4");
	
	for (var i = 0; i < 20; i++) {
		captureBar[i] = new component(64, 10, "solidGrey", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none");
	}
	captureCounter = new component("900 32px", "Arial", "solidGrey", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", "4");
	captureCard = new component(128, 320, "captureCard.png", boardX-spaceSize*2, boardY-spaceSize*5, "none", "none");
	
	factoryCard = new component(spaceSize*9, spaceSize*8, "captureCard.png", boardX-spaceSize*11, boardY-spaceSize*11, "none", "none");
	for (var i = 0; i < units.length; i++) {
		factoryCardUnits[i] = new component(50, 50, units[i].image, toPixel(3,0) + ((spaceSize-50)/2), toPixel(i*2 + 3,0) + ((spaceSize-50)/2), "player", units[i]);
		factoryCardUnitBackgrounds[i] = new component(64, 64, "factoryCardUnitBackground.png", toPixel(3,0), toPixel(i*2 + 3,0), "none", "none");
		factoryCardText[i] = new component("900 32px", "Arial", "black", toPixel(4,10), toPixel(i*2 + 3,42), "text", units[i].name);
		factoryStatCard[i] = new component(256, 64, "factoryStatCard.png", toPixel(3,0), toPixel(i*2 + 4,0), "none", "none");
		factoryUnitStats[i] = [];
		factoryUnitStats[i][0] = new component("900 32px", "Arial", "white", toPixel(3,35), toPixel(i*2 + 4,45), "text", units[i].attack);
		factoryUnitStats[i][1] = new component("900 32px", "Arial", "white", toPixel(4,30), toPixel(i*2 + 4,45), "text", units[i].movement);
		factoryUnitStats[i][2] = new component("900 32px", "Arial", "white", toPixel(5,25), toPixel(i*2 + 4,45), "text", units[i].defense);
		factoryUnitStats[i][3] = new component("900 32px", "Arial", "white", toPixel(6,27), toPixel(i*2 + 4,45), "text", units[i].sight);
	}
	
	gameArea.start();
}


function newPlayerUnit (xCord, yCord, unit) {
	playerUnits[playerUnits.length] = new component(50, 50, units[unit].image, toPixel(xCord,globalOffsetX) + ((spaceSize-50)/2), toPixel(yCord,globalOffsetY) + ((spaceSize-50)/2), "player", units[unit]);
	playerHP[playerHP.length] = new component("900 20px", "Arial", "white", toPixel(xCord,globalOffsetX) + 25 + ((64-50)/2), toPixel(yCord,globalOffsetY) + 50 + ((64-50)/2), "text", "10");
	entityLayer[xCord][yCord] = playerUnits.length-1;
}

function mapTerrain() {
	for (var i = 0; i < boardRows; i++) {
		board[i] = [];
		for (var j = 0; j < boardCols; j++) {
			board[i][j] = 0;
		}
	}
	
	//player's base
	board[1][1] = 4;
	board[1][2] = 5;
	board[2][1] = 5;
	board[1][3] = 6;
	board[3][1] = 6;
	
	//enemy base
	board[11][1] = 9;
	board[11][2] = 10;
	board[10][1] = 10;
	board[11][3] = 11;
	board[9][1] = 11;
	
	//southern island
	board[4][12] = 3;
	board[4][11] = 3;
	board[4][10] = 3;
	board[8][12] = 3;
	board[8][11] = 3;
	board[8][10] = 3;
	board[5][9] = 3;
	board[7][9] = 3;
	
	board[5][12] = 8;
	board[7][12] = 8;
	board[6][11] = 7;
	
	//southwest forrest
	board[0][10] = 1;
	board[1][10] = 1;
	board[0][11] = 1;
	board[1][11] = 1;
	board[1][12] = 1;
	board[2][11] = 1;
	board[2][12] = 1;
	board[0][9] = 1;
	board[0][8] = 1;
	board[1][9] = 1;
	board[0][12] = 8;
	board[0][10] = 8;
	
	//southeast forrest
	board[10][11] = 1;
	board[10][12] = 1;
	board[11][9] = 1;
	board[11][10] = 1;
	board[11][11] = 1;
	board[11][12] = 1;
	board[12][8] = 1;
	board[12][9] = 1;
	board[12][10] = 1;
	board[12][11] = 1;
	board[12][12] = 8;
	board[12][10] = 8;
	
	//northern mountain range
	board[6][0] = 2;
	board[6][1] = 2;
	board[6][2] = 2;
	board[6][3] = 2;
	board[5][0] = 1;
	board[5][1] = 1;
	board[5][2] = 1;
	board[5][3] = 1;
	board[7][0] = 1;
	board[7][1] = 1;
	board[7][2] = 1;
	board[7][3] = 1;
	board[6][4] = 1;
	
	//central town
	board[5][5] = 8;
	board[5][7] = 8;
	board[7][5] = 8;
	board[7][7] = 8;
	board[6][6] = 7;
}

function mapStructures() {
	for (var i = 0; i < boardRows; i++) {
		structureMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			if (board[i][j] > 6) 
				structureMap[i][j] = -20;
			else if (board[i][j] > 3)
				structureMap[i][j] = 20;
			else 
				structureMap[i][j] = 0;
		}
	}
}

function generateSpace (x,y) {
	var image = getImage(x,y);
	var space = new component(spaceSize, spaceSize, image, toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "" + x + "," + y);
	return space;
}

var gameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = boardX;
        this.canvas.height = boardY;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		this.interval = setInterval(updateGameArea, 20);
		window.addEventListener("mouseup", clicked);
		window.addEventListener('keydown', function (e) {
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = true;
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = false; 
        })
		
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type, unit) {
	this.type = type;
    this.width = width;
    this.height = height;
	this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
	this.image = new Image();
	this.image.src = color;
    this.moveable = false;
	this.text = unit
	
    this.update = function() {
		ctx = gameArea.context;
		
		if (this.type == "text") {
			ctx.font = this.width + " " + this.height;
			if (color == "solidBlue") 
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else 
				ctx.fillStyle = color;
			ctx.fillText(this.text, this.x, this.y);
		}
		
		else if (this.type == "square") {
			if (color == "blue")
				ctx.fillStyle = "rgba(69, 125, 211, 0.5)";
			else if (color == "fog") 
				ctx.fillStyle = "rgba(89, 89, 89, 0.7)";
			else if (color == "solidBlue") 
				ctx.fillStyle = "rgba(0, 78, 225, 1)";
			else if (color == "solidGrey")
				ctx.fillStyle = "rgba(106, 107, 107, 1)";
			else if (color == "solidRed")
				ctx.fillStyle = "rgba(209, 21, 30, 1)";
			else 
				ctx.fillStyle = "rgba(212, 210, 144, 0.5)";
            ctx.fillRect(this.x, this.y, this.width, this.height);
		}
		
		else {
			ctx.drawImage(
			this.image, 
			this.x, 
			this.y,
			this.width, this.height);
			this.stats = unit;
		}
    }
	
    this.newPos = function() {
		this.x = this.x + this.speedX + globalSpeedX;
		this.y = this.y + this.speedY + globalSpeedY;        
	}
} 

function updateGameArea() {
    gameArea.clear();
	
	if (gameArea.keys) {
		handleInput();
	}
	
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			spaces[i][j].newPos();
			spaces[i][j].update();
		}
	}

	if (movementHighlights != []) {
		for (var i = 0; i < movementHighlights.length; i++) {
				movementHighlights[i].newPos();
				movementHighlights[i].update();
		}
	}
	
	for (var i = 0; i < playerUnits.length; i++) {
			playerUnits[i].newPos();
			playerUnits[i].update();
	}
	
	for (var i = 0; i < playerHP.length; i++) {
			playerHP[i].newPos();
			playerHP[i].update();
	}
	
	for (var i = 0; i < enemyUnits.length; i++) {
			enemyUnits[i].newPos();
			enemyUnits[i].update();
	}
	
	for (var i = 0; i < enemyHP.length; i++) {
			enemyHP[i].newPos();
			enemyHP[i].update();
	}
	
	if (path != []) {
		for (var i = 0; i < path.length; i++) {
			path[i].newPos();
			path[i].update();
		}
	}
	
	if (terrainCardOn) {
		terrainCard.update();
		terrainCardMove.update();
		terrainCardDef.update();
	}
	
	if (unitCardOn) {
	unitCard.update();
	unitCardAttack.update();
	unitCardDef.update();
	unitCardMove.update();
	unitCardSight.update();
	}

	if (capturing && delay < 0) {
		if (frame % 7 == 0) {
			if (capturing > 0) {
				captureCounter.text = captureCounter.text-1;							
				if (captureCounter.text == Math.abs(captureVal)) {
					capturing = -4;
					//spaces[x][y].image.src = terrainImg[board[x][y]];
					delay = -2;	
				}
			}
			else if (capturing < 0) {
				capturing++;
			}
		}
		captureCard.update();
		captureCounter.update();
		
		for (var i = 0; i < captureBar.length-(20-Math.abs(captureCounter.text)); i++) {
			captureBar[i].update();
		}
	}
	
	if (buildingUnit) {
		factoryCard.update();
		for (var i = 0; i < factoryCardUnits.length; i++) {
			factoryCardUnitBackgrounds[i].update();
			factoryCardUnits[i].update();
			factoryCardText[i].update();
			factoryStatCard[i].update();
			for (var j = 0; j < factoryUnitStats[i].length; j++) {
				factoryUnitStats[i][j].update();
			}
		}
	}
	
	//fogUpdate();
	
	if (delay > 0) {
		delay--;
	}
	else if (delay == 0) {
		delay--;
		executeMoves();
	}
	
	frame++;
}

function fogUpdate() {
	fogLayer = [];
	
	for (var i = 0; i < boardRows; i++) {
		fogMap[i] = [];
		for (var j = 0; j < boardCols; j++) {
			fogMap[i][j] = 1;
		}
	}
	
	if (unitCardOn) {
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-2][toSpace(boardY,0)-1] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	else if (terrainCardOn) {
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-2] = 0;
		fogMap[toSpace(boardX,0)-1][toSpace(boardY,0)-1] = 0;
	}
	
	for (var i = 0; i < fogMap.length; i++) {
		for (var j = 0; j < fogMap[0].length; j++) {
			defog(i,j);
			if (fogMap[i][j]) {
				fogLayer[fogLayer.length] = new component(spaceSize, spaceSize, "fog", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
			}
		}
	}
	
	for (var i = 0; i < fogLayer.length; i++) {
			fogLayer[i].update();
	}
}

function defog(i,j) {
	if (entityLayer[i][j] > -1) {
		fogMap[i][j] = 0;
		
		for (var k = 0; k < spaceOffset.length; k++) {
			fogMap[i + spaceOffset[k][0]][j + spaceOffset[k][1]] = 0;
		}
		//playerUnits[entityLayer[x][y]].stats.sight
	}
}

function handleInput() {
    if (gameArea.keys[83] && globalOffsetY > boardY - spaceSize*boardCols) { // w key
		globalSpeedY = -1*scrollSpeed;
		globalOffsetY -= scrollSpeed;
	}  
	else if (globalSpeedY == -1*scrollSpeed) {globalSpeedY = 0;} //if keyup stop moving
    
	if (gameArea.keys[87] && globalOffsetY < 0) { //s
		globalSpeedY = scrollSpeed;
		globalOffsetY += scrollSpeed;
	} 
	else if (globalSpeedY == scrollSpeed) {globalSpeedY = 0;}
	
	if (gameArea.keys[65] && globalOffsetX < 0) { //d
		globalSpeedX = scrollSpeed;
		globalOffsetX += scrollSpeed;
	}
	else if (globalSpeedX == scrollSpeed) {globalSpeedX = 0;}
	
    if (gameArea.keys[68] && globalOffsetX > boardX - spaceSize*boardRows) { //a
		globalSpeedX = -1*scrollSpeed;
		globalOffsetX -= scrollSpeed;
	} 
	else if (globalSpeedX == -1*scrollSpeed) {globalSpeedX = 0;}
	
}

function clicked(event) {
	if (delay < 0 && !capturing && !buildingUnit) {
		var x = toSpace(event.clientX, globalOffsetX);
		var y = toSpace(event.clientY, globalOffsetY);
		
		if (phase == 0) {
			if (entityLayer[x][y] > -1) {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				selectedUnit = entityLayer[x][y];
				highlightMoveable(x,y);	
				terrainCardOn = false;
				unitCardAttack.text = playerUnits[entityLayer[x][y]].stats.attack;
				unitCardDef.text = playerUnits[entityLayer[x][y]].stats.defense;
				unitCardMove.text = playerUnits[entityLayer[x][y]].stats.movement;
				unitCardSight.text = playerUnits[entityLayer[x][y]].stats.sight;
				unitCardOn = 1;
				phase++;
			}
			else if (board[x][y] == 5) {
				buildingUnit = true;
			}
			else {
				if (terrainCardSpace) {
					movementHighlights = [];
				}
				
				terrainCardSpace = spaces[x][y];
				movementHighlights[0] = new component(spaceSize, spaceSize, "gold", toPixel(x,globalOffsetX), toPixel(y,globalOffsetY), "square", "none");
				terrainCardOn = true;
				terrainCardMove.text = terrainCost[board[x][y]];
				terrainCardDef.text = terrainDef[board[x][y]];
			}
		}

		else if (entityLayer[x][y] > -1) {
			if (board[x][y] > 6 && entityLayer[x][y] == selectedUnit) {
				captureStructure(x,y);
			}
			clickedReset();
		}
		
		else if (phase == 1) {
			if (spaces[x][y].moveable) {
				makeMoves(x,y,playerUnits[selectedUnit]);
				phase++;
			}
			else {
				clickedReset();
			}
		}
		
		else if (phase == 2) {
			if (moves[0][0] == x && moves[0][1] == y){
				entityLayer[moves[moves.length-1][0]][moves[moves.length-1][1]] = -1;
				moveParams = [moves[moves.length-1][0],moves[moves.length-1][1],playerUnits[selectedUnit],moves.length-1];
				path = [];
				clearMoveable();
				unitCardOn = 0;		
				executeMoves();
				if(structureMap[x][y] < 0) {
					captureStructure(x,y);
				}
			}
			else if (spaces[x][y].moveable) {
				phase = 1;
				moves = [];
				path = [];
				clicked(event);
			}
			else {
				clickedReset();
			}
		}
	}
}

function clickedReset() {
	unitCardOn = 0;
	clearMoveable();
	moves = [];
	path = [];
	phase = 0
	clicked(event);
}

function makeMoves (x,y,given) {
	var current;
	var selected = [0,0]
	moves.push([x,y]);

	while (!(arrayCompare(moves[moves.length-1],[toSpace(given.x, globalOffsetX),toSpace(given.y, globalOffsetY)]))) { //while the last position in the list of moves != the starting position
		current = -1;
		
		for (var i = 0; i < spaceOffset.length; i++) {
			if (moves[moves.length-1][0]+spaceOffset[i][0] >= 0 && moves[moves.length-1][1]+spaceOffset[i][1] >=0 && //make sure we don't check spaces off the board (@ array[-1])
				moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]] > current) {
				current = moveableGrid[moves[moves.length-1][0]+spaceOffset[i][0]][moves[moves.length-1][1]+spaceOffset[i][1]];
				selected = spaceOffset[i];
			}
		}
		
		moves.push([moves[moves.length-1][0]+selected[0],moves[moves.length-1][1]+selected[1]]);
	}
	
	for (var i = 0; i < moves.length-1; i++) {
		drawPath(i);
	}
}

function arrayCompare (array1, array2) {
	if (!array1 || !array2) {
		return false;
	}
	
	if (array1.length != array2.length) {
		return false
	}
	
	for (var i = 0; i < array1.length; i++) {
		if (array1[i] instanceof Array && array2[i] instanceof Array) {
			if (!(arrayCompare(array1[i],array2[i]))) {
				return false;
			}
		}
		
		else if (!(array1[i] == array2[i])) {
			return false;
		}
	}
	
	return true;
}

function drawPath(i) {
	/*if (i > 0) {
		if((moves[i-1][0] != moves[i][0]) && (moves[i+1][1] != moves[i][1])) {
			path[i] = new component(64, 64, "corner3.png", moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
		}
	}*/
	
	if (path[i] == undefined) {
		if (moves[i][1] != moves[i+1][1]) {
			path[i] = new component(10, 64, "verticalLine.png", (64-10)/2 + moves[i][0]*64 + globalOffsetX, moves[i][1]*64 + globalOffsetY, "path");
		}
		else {
			path[i] = new component(64, 10, "horizontalLine.png", moves[i][0]*64 + globalOffsetX, (64-10)/2 + moves[i][1]*64 + globalOffsetY, "path");
		}
	}
}

function executeMoves () {
		if (delay == -2) {
			delay = 0;
		}
		moveActual(moveParams[0],moveParams[1],moveParams[2]);
		if (moveParams[3] >= 0) {
			moveParams[0] = moves[moveParams[3]][0];
			moveParams[1] = moves[moveParams[3]][1];
			moveParams[3] = moveParams[3]-1;
			delay = 9;
		}
		else if (moveParams[3] == -1) {
			moveOver();
		}
}

function moveActual(x,y,given) {
	given.x = toPixel(x,globalOffsetX) + ((spaceSize-given.width)/2);
	given.y = toPixel(y,globalOffsetY) + ((spaceSize-given.height)/2);
	playerHP[selectedUnit].x = toPixel(x,globalOffsetX) + 32;
	playerHP[selectedUnit].y = toPixel(y,globalOffsetY) + 57;
}

/*known bugs
-will only work with friendly
-not affected by unit health
-if statment to change terrain wont work with enemy
*/

function captureStructure(x,y) {
	capturing = 1;
	captureCounter.text = Math.abs(structureMap[x][y]);
	captureVal = structureMap[x][y] + 10;//*(temp/Math.abs(temp));
	structureMap[x][y] = captureVal;
	if (board[x][y] > 8) {
		for (var i = 0; i < 20; i++) {
			captureBar[i] = new component(64, 10, "solidRed", toPixel(12,0)-32, toPixel(12,0)-i*12, "square", "none"); //This is an awful clumsy way to do this but had problems w/ edit
		}
		captureCounter = new component("900 32px", "Arial", "solidRed", toPixel(12,0)-22, boardY-spaceSize*2 + 103, "text", captureCounter.text);
		//captureCard = new component(128, 320, "captureCard.png", boardX-spaceSize*2, boardY-spaceSize*5, "none", "none");
	}
	
	if (structureMap[x][y] >= 0) {
		if (board[x][y] > 8) {
			board[x][y] = board[x][y]-5;
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
		else if (board[x][y] > 6) {
			board[x][y] = board[x][y]-2;
			spaces[x][y].image.src = terrainImg[board[x][y]];
		}
	}
}

function moveOver() {
	entityLayer[moves[0][0]][moves[0][1]] = selectedUnit;
	moves = [];
	phase = 0;
	delay = -2;
	//alert(structureMap[moves[0][0]][moves[0][1]]);
}

function highlightMoveable(x, y) {
	getMoveable(x,y);

	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			if (moveableGrid[i][j] > -1 && !(i == x && j == y)) {
				movementHighlights[movementHighlights.length] = new component(spaceSize, spaceSize, "blue", toPixel(i,globalOffsetX), toPixel(j,globalOffsetY), "square", "none");
				spaces[i][j].moveable = true;
			}
		}
	}
}

function getMoveable(givenX,givenY) {
	var potentialMoveable = {movement: playerUnits[selectedUnit].stats.movement, x: givenX, y: givenY};
	moveableSpaces = [potentialMoveable];
	moveableGrid = [];
	expandMoveable();
	generateGrid();
}

function expandMoveable() {
	for (var i = 0; i < moveableSpaces.length; i++) {
		if (moveableSpaces[i].movement > 0) {
			for (var k = 0; k < spaceOffset.length; k++){
				currX = moveableSpaces[i].x + spaceOffset[k][0];
				currY = moveableSpaces[i].y + spaceOffset[k][1];
				if (currX >= 0 && currX < board.length && currY >= 0 && currY < board[0].length //if the space being checked is on the board
					&& moveableSpaces[i].movement - terrainCost[board[currX][currY]] >= 0){
					newMoveable = {movement: moveableSpaces[i].movement - terrainCost[board[currX][currY]], x: currX, y: currY};
					moveableSpaces[moveableSpaces.length] = newMoveable;
				}
			}
		}
	}
}

function generateGrid() {
	var current = moveableSpaces[0];
	
	for (var q = 0; q <= boardRows; q++) {
		moveableGrid[q] = [];
		for (var w = 0; w <= boardCols; w++) {
			moveableGrid[q][w] = -1;
		}	
	}
	
	for (var i = 0; i < moveableSpaces.length; i++) {
		current = moveableSpaces[i];

		if (current.movement > (moveableGrid[current.x][current.y])) {
			moveableGrid[current.x][current.y] = current.movement;
		}
	}
}

function clearMoveable() {
	for (var i = 0; i < boardRows; i++) {
		for (var j = 0; j < boardCols; j++) {
			movementHighlights = [];
			spaces[i][j].moveable = false;
		}
	}
}

function getImage(x,y,category) {
	return terrainImg[board[x][y]];
}

function toPixel (given,offset) {
	return given*spaceSize + offset;
}

function toSpace(given,offset) {
	return parseInt((given-offset)/spaceSize);
}

</script>

</body>
</html>
